<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>那小学生该干什么？</title><url>https://yinanhong.site/post/onehourpolicy/</url><categories><category>键政</category></categories><tags><tag>游戏</tag><tag>教育</tag></tags><content type="html"> 近日，国家新闻出版署下发《关于进一步严格管理 切实防止未成年人沉迷网络游戏的通知》。通知要求：
所有网络游戏企业仅可在周五、周六、周日和法定节假日每日20时至21时向未成年人提供1小时服务，其他时间均不得以任何形式向未成年人提供网络游戏服务； 不得以任何形式向未实名注册和登录的用户提供游戏服务； 各级出版管理部门要加强对防止未成年人沉迷网络游戏有关措施落实情况的监督检查，对未严格落实的网络游戏企业，依法依规严肃处理； 积极引导家庭、学校等社会各方面共管共治，依法履行未成年人监护责任，为未成年人健康成长营造良好环境。 昨天在和同学聊到这个的时候，想到结合前段时间的“双减”政策（全面压减作业总量和时长，减轻学生过重作业负担），现在小学生不能上补习班了，又不能打游戏，又不能追星了，那小学生该干什么呢？
想到我的小学生小婊弟打王者的时间更少了，我很开心。但是我认为一刀切地限制未成年人玩游戏，并没有解决什么问题。
“双减”政策一定程度上要解决的是教育过度市场化导致的有失公平的问题，对娱乐圈的重锤是要解决青少年（乃至部分成年人=.=）错误价值导向的问题。那禁游戏是为了解决什么问题？
显然，就算禁了游戏，小学生周末也不会去看书学习，不会去户外活动，不会去丰富自己的精神世界。那些对禁游戏拍手叫好的家长们，是否想好了要怎样填充小孩子的业余时间？如果各位996社畜对孩子的空闲时间没有规划的话，小孩子原本玩游戏的时间去看了电视，看了直播，刷了抖音，这只不过是从干一件没多大意义的事变成干另一件更没意义的事罢了。
其实游戏本就没啥大问题，大把成年人也沉迷打牌沉迷麻将，但没人去怪扑克牌麻将啊。把一切错误都归咎到游戏上，只是家长们不愿承认自己没有做好家庭教育，而找来的说辞。沉迷游戏的问题，不应该怪游戏，应该怪教育。
另外，禁游戏真的能防止未成年人玩游戏吗？我小时候就大把小孩子拿成年人的身份证登记游戏信息了。想起我另一个小婊弟是用他妈的身份证登记的王者=.= &hellip;知乎上也有回答，韩国几年前出台政策，禁止在夜间向未成年提供游戏服务，而效果并不好。这里就不展开讨论了。
总之，禁游戏并没有结果什么实质上的问题。原本家庭教育好的小学生本就有丰富而有意义的课余活动，而对真正沉迷游戏，深受其害的这类小学生，这样的政策并解决不了什么问题。</content></entry><entry><title>用Hexo框架搭建Github Page个人博客</title><url>https://yinanhong.site/post/hexo/</url><categories><category>小玩意</category></categories><tags><tag>Hexo</tag><tag>静态博客</tag></tags><content type="html"> 本文教大家快速从0搭建一个简单的博客，更深入的内容请自行了解。朋友们可以把成果留在评论区，有任何疑问欢迎留言。
前言 拥有一个个人博客还是一件比较酷的事情，而且非常适合新手入门。不只是做前端，在做个人博客的过程中，会接触到很多技术，我自己就是从搭了这个网页开始，慢慢想搞各种各样乱七八糟的东西的。
如果过程中有不熟悉的技术，可以先跟着流程把网站搭起来，以后再慢慢研究不懂的地方。
静态网页（可跳过） 百度：
静态网页就是纯前端，没有后台，没有数据库，不含程序，不可交互，一般用于更新较少的展示型网页。
我们做网页显然不可能自己用html写出整个东西来，现在有许多好用的开源框架，比如Hexo，Jekyll，Hugo，Nust.js，Gatsby&hellip;
还有些听说比较好用，但我没用过的动态网站框架比如wordpress，感兴趣的朋友们可以自行了解下。
推荐理由（可跳过） Hexo是国内使用人数最多的框架，好处就是主题多，bug少（相对，勿怼），遇到问题基本都能找到中文的解答，特别适合新手。
对于新手来说，Github Page就很好，作为展示足够了。优点就是快，生成好的网页直接上传到github就可以显示了。缺点就是慢，大家都懂的，有时候网络不好就会打不开。
有兴趣的朋友也可以买一台云服务器，把网页部署在国内的服务器，访问起来就比较快了。阿里云的学生优惠还是非常划算的。学计算机的人应该人手一台服务器，不过新手可能不太知道服务器能用来干嘛。可以作为个人的数据库啊，学网络的时候可以把server丢到服务器上面跑啊什么的。如果只是为了放网页的话，配置起来也比较麻烦，建议大家学习到一定阶段再考虑买服务器的事。
前置技术 一丢丢前端知识，html，css，javascript，只需要稍微能阅读网页源代码就行了，真的菜鸟教程看个五分钟你就比我会的多了，因为我只看了两分钟&hellip;
Markdown语言，一种轻量级标记语言，提供非常简易的排版。现在对排版要求不高的网页文字内容，基本都是用markdown，比如Github，知乎啊啥的，都是支持插入markdown的，还有我的评论区。这个真的很简单，看个十分钟就会用了，而且程序员必会用到这个的。然后推荐个markdown编辑工具叫Typora。
我的操作环境是win10，然后大家可以用vs code或者其他你熟悉的ide。因为最近看到有同学在用记事本敲代码，让我很绝望。
安装Hexo 官方文档里面写的很清楚。我下面列举主要步骤。
安装git（可选） Hexo可以用git在生成静态文件的时候，推送到云端。请自行找个靠谱的教程安装一下git，并不需要熟悉git的使用。 下面这个链接仅供参考。
Windows系统Git安装教程（详解Git安装过程） - 知乎 (zhihu.com)
安装Node.js Hexo需要Node.js环境，所以要先安装Node.js。
Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 Node.js 的包管理器 npm，是全球最大的开源库生态系统。
LTS是Long-Term Support，那我们就接受一下他的recommend，下这个版本好了。
安装的时候一直点next就好了，注意到这一步的时候确认一下add to path有勾选上，如果没有的话等一下要自己添加一下path。
npm是node.js的包管理工具，安装node.js的时候会顺带一起安装。
安装成功后在命令行输入下面内容，能看到版本号就说明安装成功了。
node -v npm -v 安装Hexo 在命令行输入以下命令
npm install hexo 安装好之后可以输入npx hexo -v查看一下版本。使用npx hexo &lt;command>来执行hexo命令。
可以选择把hexo目录下的node_modules添加到环境变量，这样就可以在命令行使用hexo &lt;command>执行hexo命令。
生成网页 创建一个文件夹，在本地存储你的博客项目。在命令行中输入以下命令。
npx hexo init &lt;文件夹路径> 比如我的路径是C:\Users\Tutoo\Desktop\blog 执行后文件夹里会出现一堆文件。_config.yml文件是网站的配置信息，source是用户资源，我们写的博客就放在source里面，themes存放主题的地方。
我们先进行继续下一步，其他东西大家可以慢慢研究，现在先把网站搭建起来。
发布到本地端口 初始化后，生成的Hexo项目里面自带了一个默认主题landscape。主题就是类似皮肤，可以换掉的。
做到这一步，我们在命令行中进入到Hexo项目的根目录。不会用cd命令的自己查一下。
输入以下命令
npx hexo server 然后hexo就会把你现在的项目生成出网页来，然后发布在本地端口，你可以在浏览器中打开http://localhost:4000，来查看网页现在是什么样子的。
在_config.yml文件里你可以修改一些参数。
搞好之后网站就是这个样子的。这个主题比较简陋，功能也不多，想要其他更fancy的功能可以去找其他主题。
看到这里可以直接往下到博客内容管理。
选个主题（可选） 初始化后，生成的Hexo项目里面自带了一个默认主题landscape。大家可以搜索自己喜欢的主题换掉，Hexo有很多好看的开源的主题。Themes | Hexo
把你想用的主题下载下来后，解压到themes目录下，然后在Hexo项目的根目录下的_config.yml文件里，把theme更改成对应的主题名称。
主题目录下的_config.yml文件里，把一些参数替换成你自己的。然后找到里面用到的图片，logo，头像之类的统统替换成你自己的。
博客内容管理 每一篇博客都对应一个markdown文件。存放的位置是source/_posts/。在命令行中输入
npx hexo new "first-blog" 就会在source/_posts/生成first-blog.md文件。你就可以在这个文档里用markdown写文章啦。
如果需要插入图片之类的，我自己的做法是在同一个目录下建一个文件夹来存图片，然后直接用markdown插入图片，大家也可以用图床之类的。
可以开启server看一下效果。
发布博客 我们的博客不能只在本地看，要发布到服务器上别人才能访问。
创建Github Page仓库 在github中新建一个仓库（repository），仓库名必须是用户名.github.io。
生成静态博客 在_config.yml文件里，16行处的域名替换成你的github page域名，比如https://yinan-hong.github.io/
25行是生成的静态文件存放的目录。
在本地项目的根目录，在命令行中输入以下内容
npx hexo generate 在/public/目录下就生成了博客的静态网页文件。
发布到云端 Hexo很方便的一点是，可以用git在生成静态文件的同时，发布到云端。
但我们比较菜，不会用git怎么办？只需要把/public/目录下的所有文件上传到刚才新建的github仓库里就ok了(拖到浏览器里就行)。上传成功后，等待十几秒，就可以通过https://用户名.github.io/访问博客了。
写在最后 本文是为了帮助新手快速搭建起第一个博客，Hexo还有很多用法，大家可以自行了解。
其实把网站搭起来并不难，难的地方在于博客的内容。我刚开始写公众号的时候，常常觉得自己知识储备不够，不能做到深刻地探讨一些问题。我的一位老同学跟我说，要有输入才有输出。我觉得他讲的非常有道理。
之前有同学说我挺强的，真的不是&hellip; 其实我知道我很菜，只不过周围的人可能比我更菜&hellip; 最近挣扎于期末考试和欧洲杯&hellip; 暑假来了，学习计划倒是有，希望这次真的能弯道超一下车吧&hellip;</content></entry><entry><title>KMP算法详解</title><url>https://yinanhong.site/post/kmp/</url><categories><category>算法</category></categories><tags><tag>KMP算法</tag><tag>字符串匹配</tag></tags><content type="html"> 期末没时间，水一篇KMP（Knuth-Morris-Pratt）算法。
KMP算法是一种字符串匹配算法，其实字符串匹配都是可以暴力求解的，KMP算法是进行了优化，减少了无效的匹配，从而节省时间。
一道题目 题目描述
给定一个字符串（模式串）和一些待查找的字符串，求每个待查找字符串在模式串中出现的次数（可重叠） 若使用C++只能include一个头文件iostream；若使用C语言只能include一个头文件stdio 程序中若include多过一个头文件，不看代码，作0分处理 输入
测试数据有多组（测试组数 &lt;= 5）， 第一行包括一个字符串P，长度不超过105，且非空串 第二行包括一个整数N，代表待查找的字符串数量 (1 &lt;= N &lt;= 5) 接下来的N行，每一行包括一个待查找的字符串，其长度不超过50，且非空串 输出
对于每组测试数据， 输出每个待查找字符串出现的次数， 具体输出见样例 样例输入
aabbcc 3 aa bb cc ababab 1 aba 样例输出
aa:1 bb:1 cc:1 aba:2 题目解析
这道题就是一个典型的在模式串中匹配子串的题目，我在上课时想快点敲完，就直接用暴力求解了。假设模式串长度为n1，子串长度为n2，暴力求解就是从模式串的s[0]到s[n1 - n2]，挨个对模式串进行匹配。
这样需要进行 n1 - n2 次匹配，然后每次匹配中，要匹配 n2 个字符，所以时间复杂度是O[(n1-n2)*n2]
额这样做在普通课程的oj上是可以通过的，但如果是ACM题的话是妥妥的时间超限。是蓝桥杯的话，也是不能通过后几个样例的。
AC代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include &lt;iostream>using namespace std; const int LEN = 100001; int main() { char* P = new char[LEN]; char* sub = new char[LEN]; int n; while (cin >> P >> n) { int SIZE = 0; //模式串长度 for (; P[SIZE] != '\0'; SIZE++); //不给引用库函数，自己求一下strlen for (int i = 0; i &lt; n; i++) { //输入子串 cin >> sub; int size = 0; //子串长度 for (; sub[size] != '\0'; size++); int cnt = 0; for (int j = 0; j &lt; SIZE - size + 1; j++) { int matched = 0; //记录匹配的字符数 for (int k = 0; k &lt; size; k++) //模式串片段与子串进行匹配 if (P[j + k] == sub[k]) matched++; else break; if (matched == size) cnt++; } cout &lt;&lt; sub &lt;&lt; ":" &lt;&lt; cnt &lt;&lt; endl; } } delete[] sub; delete[] P; } KMP算法 KMP算法就是会省去很多无效的匹配。其实算法的过程是模拟了人的思维，大家可以体会一下。
用KMP算法进行字符串匹配时，我们用两个指针i，j分别指向模式串当前匹配到的位置和目标串当前匹配到的位置。在暴力求解中，i指针在每一round都要回溯到main_str[round]的位置，而在KMP算法中是不需要的。
失配后，下一round从第几位开始匹配？ 下图的例子，在round n+1发生了失配。
此时i指针不动，j指针回溯，进行round n+2的匹配。
因为在round n匹配s[2]时，可以理解成同时匹配了round n+2的s[0]字符，所以round n+2中，匹配只需从s[3]开始。
在对应位置匹配失败后，j指针要回溯到目标串的位置取决于目标串中的重复串。通常将回退位置储存在next数组里面。
next数组 用KMP算法求解，第一步就是计算next数组，这个数组存的是，子串的某一位发生失配后，需要从子串的第几位开始重新匹配，即失配后子串指针退回到的位置。
求next数组代码 下面是求next数组的代码，非常抽象，下面解释代码为什么要这样子写。（因为几乎所有教程里，进行匹配时用的指针起名为i，j，求next时候的指针也起名为i，j，实在让新手看得一头雾水。这里为了说明这两对指针没有半毛钱关系，下面我用x，y来命名。）
1 2 3 4 5 6 7 8 9 10 11 void getNext(char* s, int*&amp; next) { int len = strlen(s); int x = 0, y = -1; //x为当前字符下标，y为寻找重复串的辅助指针 next[0] = -1; //为方便求next和匹配时判断 while (x &lt; len - 1) { if (y == -1 || s[x] == s[y]) next[++x] = ++y; //有重复串，则记录退回位置 else y = next[y]; //不构成重复串，将y指针退回（具体看下面） } } 再说一遍，求next数组就是在子串中找重复串，让失配后回退到对应的位置，减少无效的匹配。
前三个字符没有构成重复串，所以失配时子串下标均退回到0。line 9保证了，没有构成重复串时，y指针是一直指向首位置的，因为line 7所以next[1]到next[3]的值都是0。
计算到x == 3时，s[x] == s[y]，即s[3]与s[0]构成重复串，所以如果在s[4]处发生失配，在失配前，s[3]是匹配成功的，说明s[0]也是会匹配成功的，所以下一round的匹配只需从s[1]开始。
同理，如果在s[5]发生失配，在下一round中只需从s[2]开始进行匹配。
让这条字符串再多一位，当计算到x == 5时，y == 2，是不会构成重复串的，那line 9就能确保next[6]的值为0。对应的在匹配中的情况是，在s[6]处发生失配，j指针需要退回到0。
KMP代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int KMP(char* s_main, char* s_aim) { int len1 = strlen(s_main); int len2 = strlen(s_aim); int* next = new int[len2]; getNext(s_aim, next); int i = 0, j = 0; //模式串位置，目标串位置 while (i &lt; len1 &amp;&amp; j &lt; len2) { //j == -1,即s[0]匹配不成功，i后移，j回到位置0，或 //匹配成功，两个指针均后移 if (j == -1 || s_main[i] == s_aim[j]) i++, j++; else j = next[j]; //失配，回溯j } if (j == len2) //匹配成功，返回模式串中目标串的位置 return i - j; else return -1; } 上面求next的缺陷 如果模式串是这样的，那目标串中的每个a都要和模式串中的b匹配一下，那round 2 到round 6的匹配都是无效的。因为在round 1 中已经确定了，目标串需要至少往后挪6位才有可能匹配到。
更一般的情况是下面这样的，在round n匹配失败后，回退到第一个c显然是没用的，应该再往前回退。
改进getNext 其实只用加个判断。如果求next时发现前面有一样的字符，则取前一个字符的next。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void getNext(char* s, int*&amp; next) { int len = strlen(s); int x = 0, y = -1; //x为当前字符下标，y为寻找重复串的辅助指针 next[0] = -1; while (x &lt; len - 1) { if (y == -1 || s[x] == s[y]) { if (s[++x] == s[++y]) //s[y]==s[x]字符相同，往回取next，避免无效匹配 next[x] = next[y]; //意思是避免匹配了s[x],又倒回去匹配s[y]了（上图的c和c） else next[x] = y; //有重复串，则记录退回位置 } else y = next[y]; //不构成重复串，将y指针退回 } } 往回取next不会影响y的值，这样遇到下面这种情况，求得的next数组是{-1, -1, -1, -1, -1, 5}。进行匹配时，在&rsquo;b&rsquo;处失配，后面的round也只会匹配最后两个字符。
二道算法题——KMP算法 题目描述
学习KMP算法，给出主串和模式串，求模式串在主串的位置 输入
第一个输入t，表示有t个实例 第二行输入第1个实例的主串，第三行输入第1个实例的模式串 以此类推 输出
第一行输出第1个实例的模式串的next值 第二行输出第1个实例的匹配位置，位置从1开始计算，如果匹配成功输出位置，匹配失败输出0 以此类推 样例输入
3 qwertyuiop tyu aabbccdd ccc aaaabababac abac 样例输出
-1 0 0 5 -1 0 1 0 -1 0 0 1 8 题目解析
通过观察样例，这道题是没有用优化过的next求法的。注意输出从1开始，搜索失败输出0。
AC代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include &lt;iostream>#include &lt;string>using namespace std; void getNext(char* s, int*&amp; next) { int len = strlen(s); int x = 0, y = -1; //x为当前字符下标，y为寻找重复串的辅助指针 next[0] = -1; //为方便求next和匹配时判断 while (x &lt; len - 1) { if (y == -1 || s[x] == s[y]) next[++x] = ++y; //有重复串，则记录退回位置 else y = next[y]; //不构成重复串，将y指针退回（具体看下面） } } void print(int* next, int len) { for (int i = 0; i &lt; len; i++) cout &lt;&lt; next[i] &lt;&lt; ' '; cout &lt;&lt; endl; } int KMP(char* s_main, char* s_aim) { int len1 = strlen(s_main); int len2 = strlen(s_aim); int* next = new int[len2]; getNext(s_aim, next); print(next, len2); int i = 0, j = 0; //模式串位置，目标串位置 while (i &lt; len1 &amp;&amp; j &lt; len2) { //j == -1,即s[0]匹配不成功，移动i，j回到位置0 //或匹配成功，两个指针均后移 if (j == -1 || s_main[i] == s_aim[j]) i++, j++; else j = next[j]; //失配，回溯j } if (j == len2) //匹配成功，返回模式串中目标串的位置 return i - j; else return -1; } int main() { int t; const int MAX_LEN = 10001; char* s_main = new char[MAX_LEN]; char* s_aim = new char[MAX_LEN]; cin >> t; while (t--) { cin >> s_main >> s_aim; cout &lt;&lt; KMP(s_main, s_aim) + 1 &lt;&lt; endl; } } 三道算法题——特殊的语言 题目描述
某城邦的语言，每个字是由两个字母构成的。 考古学家发现把他们的文字数字化之后，当想搜索特定的句子时，总会匹配到错误的地方。 比如一段文字是aabcdaabcdef，想要搜索abcd，应当搜到的是aabcda abcd ef 却会得到额外的一个并不符合该语言语法的结果a abcd aabcdef （因为每个字由两个字符组成，这样匹配就把正确的“字”拆开了）。 请你帮他实现正确的匹配算法。 输入
每组数据两行，第一行为该语言的主串，第二行为模式串， 都由大写或小写英文字母组成，长度都不超过 10000，且一定为偶数个。 输出
每组数据输出正确匹配的次数 样例输入
abcdaabbab ab AbdcAbdcAbqAbdcAbdcAbp AbdcAb 样例输出
2 2 题目解析
因为两个字母为一个字，第二个样例中
AbdcAbdcAbqAbdcAbdcAbp和
AbdcAbdcAbqAbdcAbdcAbp
均符合，有重叠，注意不要漏掉。
AC代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include &lt;iostream>#include &lt;string.h>using namespace std; void getNext(char* s, int*&amp; next) { int len = strlen(s); int x = 0, y = -1; //x为当前字符下标，y为寻找重复串的辅助指针 next[0] = -1; while (x &lt; len - 1) { if (y == -1 || s[x] == s[y]) { if (s[++x] == s[++y]) next[x] = next[y]; //后一个字符相同，往回取next，避免无效匹配 else next[x] = y; //有重复串，则记录退回位置 } else y = next[y]; //不构成重复串，将y指针退回 } } int KMP(char* str, char* key) { int len1 = strlen(str); int len2 = strlen(key); int* next = new int[len2]; getNext(key, next); int i = 0, j = 0, cnt = 0; while (i &lt; len1) { if (j == -1 || str[i] == key[j]) i++, j++; else j = next[j]; if (j == len2) { //匹配成功 if (i % 2 == 0) //判断匹配位置是否为2的倍数 cnt++; i = i - len2 + 2; //回溯i，否则漏掉重叠 j = 0; //回退j } } delete[] next; return cnt; } int main() { const int MAX = 10086; char str[MAX], key[MAX]; while (cin >> str >> key) { int t = KMP(str, key); cout &lt;&lt; t &lt;&lt; endl; } } 写在后面 额本来想水一下，然后不小心写详细了&hellip;
kmp算法有点难理解，我举得例子几乎涵盖了所有情况，如果还是看不懂的可以来问我=.=
参考资料和推荐阅读 有参考：https://www.cnblogs.com/dusf/p/kmp.html
有参考：http://data.biancheng.net/view/180.html
推荐阅读：https://zhuanlan.zhihu.com/p/83334559</content></entry><entry><title>AVL树和Trie树</title><url>https://yinanhong.site/post/avltree/</url><categories><category>数据结构</category><category>算法</category></categories><tags><tag>AVL树</tag><tag>平衡二叉树</tag><tag>数据结构</tag><tag>Trie</tag></tags><content type="html"> 本文介绍AVL树和Trie树。Trie树是因为正好做到所以就顺便记录一下。
文章里插入了一些gif，虽然我已经压缩到了3、4m的样子，但加载起来还是卡卡的，同学们可以等加载好之后刷新一下再看就流畅了。
AVL树 Wiki: 在计算机科学中，AVL树是最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(logn)。
AVL树由前苏联的数学家 Adelse-Velskil 和 Landis 在1962 年提出。
AVL树就是在插入和删除的操作时，动态调整树的结构，使AVL树的任意两颗子树的高度差&lt;=1。平衡二叉树查询时，每进行一次判断能排除一半的节点，所以复杂度是O(log2n)。如果在插入和删除中不进行动态调整，那树结构有可能会退化成链表，或者会存在很长的直链，导致查询的复杂度最坏会到O(n)。
平衡因子 **平衡因子（Balance Factor）**是节点的左右子树高度差，二叉平衡树中，平衡因子只能取0, 1, -1。有些书上规定平衡因子是左高减右高，有些则是反过来，其实影响不大，只需在对应情况下进行正确的旋转操作就行。本文中平衡因子是取左子树高度减右子树高度。
节点结构 1 2 3 4 5 6 7 8 class BiNode { public: int key; // 关键值 int bf; // 平衡因子 BiNode* lChild, * rChild; BiNode(int kValue, int bValue) { /*略*/ } ~BiNode() { /*略*/ } }; 常见操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 二叉排序树 class BST { private: BiNode* root; // 根结点指针 void rRotate(BiNode*&amp; p); //p为根的右旋操作 void lRotate(BiNode*&amp; p); //p为根的左旋操作 void leftBalance(BiNode*&amp; t); //左平衡处理 void rightBalance(BiNode*&amp; t); //右平衡处理 int insertAVL(BiNode*&amp; t, int key, bool&amp; taller); // 插入元素并做平衡处理 void del(BiNode*&amp; t, key); //删除操作，考完试补 todo public: BST(); void insertAVL(int key); // 二叉排序树插入元素 void del(int key); // 删除节点 ~BST(); void inOrder(); // 中序遍历 }; 节点的插入和与平衡 上图左侧是平衡二叉树，节点上方数字为高度，当插入key为99的节点时，key为66的节点的平衡因子变为-2，发生了失衡。这时需要对二叉树进行调整，来保证所有节点满足平衡因子的绝对值&lt;=1。
最小失衡树 在新插入的结点向上查找，以第一个平衡因子的绝对值超过 1 的结点为根的子树称为最小不平衡子树。也就是说，一棵失衡的树，是有可能有多棵子树同时失衡的。而这个时候，我们只要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。
平衡二叉树的失衡调整主要是通过旋转最小失衡子树来实现的。根据旋转的方向有两种处理方式，左旋 与 右旋 。
旋转的目的就是减少高度，通过降低整棵树的高度来平衡。哪边的树高，就把那边的树向上旋转。
左旋 失衡节点的右孩子变为根节点 右孩子的左子树变为失衡节点的右子树 失衡节点变为右孩子的左子树 1 2 3 4 5 6 void BST::lRotate(BiNode*&amp; p) { BiNode* rc = p->rChild; p->rChild = rc->lChild; rc->lChild = p; p = rc; } 右旋 失衡节点的左孩子变为根节点 左孩子的右子树变为失衡节点的左子树 失衡节点变为左孩子的右子树 1 2 3 4 5 6 void BST::rRotate(BiNode*&amp; p) { BiNode* lc = p->lChild; p->lChild = lc->rChild; lc->rChild = p; p = lc; } 先左旋后右旋 图先放，下面紧接着就解释为什么要有二次旋转的操作。
对失衡节点的左节点进行左旋 对失衡节点进行右旋 先右旋后左旋 对失衡节点的右节点进行右旋 对失衡节点进行左旋 四种插入对应的旋转 这棵树插入节点55后，失衡的节点是60，而且是左侧高。如果对66进行左旋处理如下图，发现树依旧失衡。
所以我们需要判断，失衡节点是左高还是右高，失衡节点的子节点是左高还是右高，来区分不同的情况。像上图的，失衡节点是左侧高，失衡节点的左子树为右侧高，此时需要进行两次旋转。
实际上有四种插入，分别对应四种旋转
插入在失衡节点的左子树的左子树，进行左旋 插入在失衡节点的右子树的右子树，进行右旋 插入在失衡节点的左子树的右子树，进行先左旋后右旋 插入在失衡节点的右子树的左子树，进行先右旋后左旋 在代码实现时，先判断失衡节点需要进行左旋还是右旋，然后在平衡处理的函数中，判断子节点是否需要进行旋转。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // t为根的二叉排序树作左平衡旋转处理 void BST::leftBalance(BiNode*&amp; t) { BiNode *l = t->lChild; switch (l->bf) { case LH: t->bf = l->bf = EH; rRotate(t); break; // 左子节点为左高，对应第一种插入 case RH: // 左子节点为右高，对应第三种插入 BiNode *lr = l->rChild; switch (lr->bf) { // 调整平衡因子 case LH: t->bf = RH; l->bf = EH; break; case EH: t->bf = l->bf = EH; break; case RH: t->bf = EH; l->bf = LH; break; } lr->bf = EH; lRotate(t->lChild); // 进行先左旋后右旋 rRotate(t); } } // t为根的二叉排序树作右平衡旋转处理 void BST::rightBalance(BiNode*&amp; t) { BiNode* r = t->rChild; switch (r->bf) { case RH: t->bf = r->bf = EH; lRotate(t); break; // 右子节点为右高，对应第二种插入 case LH: // 右子节点为左高，对应第四种插入 BiNode* rl = r->lChild; switch (rl->bf) { // 调整平衡因子 case RH: t->bf = LH; r->bf = EH; break; case EH: t->bf = r->bf = EH; break; case LH: t->bf = EH; r->bf = RH; break; } rl->bf = EH; rRotate(t->rChild); // 进行先右旋后左旋 lRotate(t); } } 删除操作 todo&hellip;
完整样例代码 输入
第一行输入测试数据组数t； 每组测试数据，第一行输入结点数n, 第二行输入n个结点值。 输出
对每组测试数据，按中序遍历的顺序输出树中，结点值及平衡因子（测试数据没有空树） 即输出"结点值:平衡因子"，不同结点之间间隔一个空格。 样例输入
8 3 64 5 1 3 64 5 13 6 64 78 5 1 13 15 6 64 78 5 1 13 10 3 64 78 100 3 64 80 70 6 64 30 80 90 70 68 6 64 30 80 90 70 75 样例输出
1:0 5:0 64:0 5:0 13:0 64:0 1:0 5:1 13:0 15:0 64:0 78:0 1:0 5:0 10:0 13:0 64:-1 78:0 64:0 78:0 100:0 64:0 70:0 80:0 30:0 64:0 68:0 70:0 80:-1 90:0 30:0 64:1 70:0 75:0 80:0 90:0 AC代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 #include &lt;iostream>using namespace std; #define LH 1 // 左高 #define EH 0 // 等高 #define RH -1 // 右高 class BiNode { public: int key; // 关键值 int bf; // 平衡因子 BiNode* lChild, * rChild; BiNode(int kValue, int bValue) { key = kValue; bf = bValue; lChild = NULL; rChild = NULL; } ~BiNode() { key = 0; bf = 0; lChild = NULL; rChild = NULL; } }; // 二叉排序树 class BST { private: BiNode* root; // 根结点指针 void rRotate(BiNode*&amp; p); void lRotate(BiNode*&amp; p); void leftBalance(BiNode*&amp; t); void rightBalance(BiNode*&amp; t); int insertAVL(BiNode*&amp; t, int key, bool&amp; taller); // 插入元素并做平衡处理 void inOrder(BiNode* p); public: BST(); void insertAVL(int key); // 二叉排序树插入元素 ~BST(); void inOrder(); // 中序遍历 }; // 以p为根的二叉排序树作右旋处理 void BST::rRotate(BiNode*&amp; p) { BiNode* lc = p->lChild; p->lChild = lc->rChild; lc->rChild = p; p = lc; } // 以p为根的二叉排序树作左旋处理 void BST::lRotate(BiNode*&amp; p) { BiNode* rc = p->rChild; p->rChild = rc->lChild; rc->lChild = p; p = rc; } // t为根的二叉排序树作左平衡旋转处理 void BST::leftBalance(BiNode*&amp; t) { BiNode *l = t->lChild; switch (l->bf) { case LH: t->bf = l->bf = EH; rRotate(t); break; case RH: BiNode *lr = l->rChild; switch (lr->bf) { case LH: t->bf = RH; l->bf = EH; break; case EH: t->bf = l->bf = EH; break; case RH: t->bf = EH; l->bf = LH; break; } lr->bf = EH; lRotate(t->lChild); rRotate(t); } } // t为根的二叉排序树作右平衡旋转处理 void BST::rightBalance(BiNode*&amp; t) { BiNode* r = t->rChild; switch (r->bf) { case RH: t->bf = r->bf = EH; lRotate(t); break; case LH: BiNode* rl = r->lChild; switch (rl->bf) { case RH: t->bf = LH; r->bf = EH; break; case EH: t->bf = r->bf = EH; break; case LH: t->bf = EH; r->bf = RH; break; } rl->bf = EH; rRotate(t->rChild); lRotate(t); } } int BST::insertAVL(BiNode*&amp; t, int key, bool&amp; taller) { if (!t) { t = new BiNode(key, 0); taller = true; } else if (key == t->key) { //存在相同key节点，不再插入 taller = false; return 0; } else if (key &lt; t->key) { //搜寻左子树 if (!insertAVL(t->lChild, key, taller)) //未插入 return 0; if (taller) //插入成功则树“长高” switch (t->bf) { case LH: leftBalance(t); taller = false; break; //原本左侧高，左平衡处理 case EH: t->bf = LH; taller = true; break; //原本等高，现在左侧高 case RH: t->bf = EH; taller = false; break; //原本右侧高，现在等高 } } else { //搜寻右子树 if (!insertAVL(t->rChild, key, taller)) return 0; if(taller) switch (t->bf) { case LH: t->bf = EH; taller = false; break; case EH: t->bf = RH; taller = true; break; case RH: rightBalance(t); taller = false; break; } } return 1; } void BST::inOrder(BiNode* p) { if (p) { inOrder(p->lChild); cout &lt;&lt; p->key &lt;&lt; ':' &lt;&lt; p->bf &lt;&lt; ' '; inOrder(p->rChild); } return; } // 二叉排序树初始化 BST::BST() { root = NULL; } BST::~BST() { root = NULL; } // 插入元素并作平衡处理 void BST::insertAVL(int key) { bool taller = false; insertAVL(root, key, taller); } // 中序遍历 void BST::inOrder() { inOrder(root); } int main(void) { int t; cin >> t; while (t--) { // 构建二叉平衡树，并在插入元素时做平衡处理 int n, elem; cin >> n; BST tree; while (n--) { cin >> elem; tree.insertAVL(elem); } tree.inOrder(); cout &lt;&lt; endl; } return 0; } 参考资料 https://zhuanlan.zhihu.com/p/56066942
https://www.jianshu.com/p/65c90aa1236d
Trie树 Trie树，字典树，前缀树。是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来节约存储空间，最大限度地减少无谓的字符串比较，查询效率比哈希表高。
因为题目没有要求，这里只给出建树和搜索的实现。有兴趣的朋友可以自己是现实一下大小写区分、输入查重、搜索单词等Trie树常见操作。代码注释非常详细，这里就不多做解释了。
完整样例代码 题目描述
输入的一组单词，创建Trie树。输入字符串，计算以该字符串为公共前缀的单词数。 输入
测试数据有多组 每组测试数据格式为： 第一行：一行单词，单词全小写字母，且单词不会重复，单词的长度不超过10 第二行：测试公共前缀字符串数量t 后跟t行，每行一个字符串 输出
每组测试数据输出格式为： 第一行：创建的Trie树的层次遍历结果 第2~t+1行：对每行字符串，输出树中以该字符串为公共前缀的单词数。 样例输入
5 abd abcd bcd efg hig 3 ab bc abcde 样例输出
abehbcficddggd 2 1 0 AC代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 #include &lt;iostream>#include &lt;queue>using namespace std; class Node { public: char data; Node** next; bool is_leaf; Node(char data) { this->data = data; next = new Node * [26]; for (int i = 0; i &lt; 26; i++) next[i] = nullptr; is_leaf = true; } ~Node() { delete next; } }; class Trie { private: Node* root; void insert(Node* node, char* str); void search(Node* node, char* str, int&amp; cnt); void search(Node* node, int&amp; cnt); void destroy(Node* node); public: Trie(); void insert(char* str); int search(char* str); void level_order(); ~Trie(); }; Trie::Trie() { root = new Node('\0'); } Trie::~Trie() { destroy(root); delete root; } //深度优先，删除Trie void Trie::destroy(Node* node) { for (int i = 0; i &lt; 26; i++) { if (node->next[i]) { if (!node->next[i]->is_leaf) destroy(node->next[i]); //从叶子结点开始删 delete node->next[i]; } } node->is_leaf = true; } void Trie::insert(char* str) { insert(root, str); } void Trie::insert(Node* node, char* str) { if (*str == '\0') //字符串结束 return; int pos = *str - 'a'; //取子节点位置 if (!node->next[pos]) { node->next[pos] = new Node(*str); //新建子树 node->is_leaf = false; } insert(node->next[pos], str + 1); //插入字符串下一位 } int Trie::search(char* str) { int cnt = 0; //记录公共前缀单词数 search(root, str, cnt); return cnt; } //匹配前缀 void Trie::search(Node* node, char* str, int&amp; cnt) { if (*str == '\0') { //前缀匹配成功，搜索以当前节点为根的叶子数 search(node, cnt); return; } int pos = *str - 'a'; //取当前字符位置 if (!node->next[pos]) //前缀匹配失败 return; search(node->next[pos], str + 1, cnt); } //搜索公共前缀单词数，即叶子数，深度优先 void Trie::search(Node* node, int&amp; cnt) { if (node->is_leaf) { //找到叶子，返回 cnt++; return; } for (int i = 0; i &lt; 26; i++) //子节点存在则向下搜索 if (node->next[i]) search(node->next[i], cnt); } void Trie::level_order() { if (!root) return; queue&lt;Node*>q; q.push(root); while (!q.empty()) { Node* n; n = q.front(); q.pop(); for (int i = 0; i &lt; 26; i++) //将当前节点的所有子节点存入队列 if (n->next[i]) { cout &lt;&lt; n->next[i]->data; q.push(n->next[i]); } } cout &lt;&lt; endl; } int main() { int t; const int MAX_LETTER = 11; while (cin >> t) { Trie trie; char* word = new char[MAX_LETTER]; for (int i = 0; i &lt; t; i++) { cin >> word; trie.insert(word); } delete[] word; trie.level_order(); char* prefix; cin >> t; for (int i = 0; i &lt; t; i++) { prefix = new char[MAX_LETTER]; cin >> prefix; int cnt = trie.search(prefix); cout &lt;&lt; cnt &lt;&lt; endl; delete[] prefix; } } }</content></entry><entry><title>高考季 | 谈谈专业选择和生涯规划</title><url>https://yinanhong.site/post/majorcareer/</url><categories><category>生活杂谈</category></categories><tags><tag>高考</tag><tag>生涯规划</tag></tags><content type="html">  生涯规划（Career management）在我看来，是不可缺失，而国内的教育体系却又缺失了的部分。本文我会结合自身经历，谈谈专业选择和我现在的看法。
为什么想谈生涯规划  中国的家长喜欢把孩子的一切都安排好，我们这一代年轻人是从什么时候开始做自己的选择的呢？是中考填志愿？是高中分科？是高考选择城市和学校？是到了大学才自己考虑是否读研？
 有太多人不知道自己想要什么，或是根本就没想过自己想要什么。国内的教育太不多元了，最重要的事就是中考和高考，然后就没了。在学生时代只需要好好学习，大家很少有机会去探索，也没有意识去寻找自己喜欢什么。我问过一些身边的同学，他们想做什么或想成为什么，得到的答案大多都是好好学习好好工作，赡养父母。不知道屏幕前的各位，是否清楚自己的理想是什么呢？
 我的经历  我小时候和大多数人一样，大人才不会和小孩子讨论哪怕是小孩子自己的人生规划，所以我该上学就上学，从来都没想过是为了什么。小学六年级的时候，家人把我送去了新加坡读书，想让我考那里的初中。Well，把十一岁的小孩子一个人丢在国外，自然是不可能好好学习的。于是两年后啥也没干的我就灰溜溜地滚回国了。
  初中过后就更没人管我了，实属孤儿。记得中考时翠园来我们初中签约，老师是比较推荐我签的，但我因为听说深中不用穿校服，还可以走读，就想考深中，也没想过考不考得上啥的。当时家里人就从来都没了解过我的成绩，听了老师的话之后就一个劲劝我签约，简直大无语。不过志愿填报的账号只有我自己知道，我想怎么填怎么填，还好考上了&hellip; 后来开填报志愿的家长会，只有我这个孤儿没家长去，老师就让我自己听。因为成绩三年都是全班第一年级前20，我的座位在班级c位，当时我被叔叔阿姨们团团包围，实属尴尬。离谱吧。
 高中时吧，因为当时的生物老师年轻漂亮，我生物课听的是格外认真，也渐渐发现自己挺喜欢这个天坑学科。高一参加igem比赛的时候，国庆和暑假是什么让我天天早起坐一个多小时地铁去深大做实验？那当然是爱啊!!!
 记得某次生物做完实验要上传照片，然后我顺带传了我的微信号&hellip;. bksw
 在实验室剪剪拼拼DNA，养养大肠杆菌，真的好快乐，感觉我就是改造物种的上帝&hellip; Anyway，考虑到现实因素，高考后我还是没有选择我更喜欢的基础学科。
 现在其实不后悔，毕竟互联网行业的薪水还是很香的，但遗憾却是一辈子的了。我时常会跟朋友吐槽我现在学这些东西有多痛苦，如果当时学了生物或者学医，学英语啥的，现在应该会学得开心很多吧。毕竟，转行互联网什么时候不可以转？
 本科专业的选择  其实我现在对所有人的建议是，在有条件的基础上，选自己喜欢的。
 讲一些热门专业吧。大概分那么几类，金融经管算一类，计算机，建筑类，硬核工科类，基础学科物化生，医学，师范类，文史类，艺术类。
金融经管类  有很多人说，学金融经管类的，需要家里有资源。确实，要是家里有矿，你想学啥学啥，没人拦你。不过金融经管类行业比较卷学历，如果本科没有好学历的话，大概率也是要读一个名校研究生之类的，出来才比较好混。像这种比较看重学历的行业，国外名校肯定是最优先考虑的，如果是普通人想选择这个行业/专业的话，要考虑家庭能不能承担得起教育投入。
计算机类  互联网行业绝对是普通人实现阶级跨越的有效途径。现在招程序员并没有非常看重学历，有好的学历当然很加分，但没有也没关系，看的其实还是主要是技术。甚至不是计算机专业的，都没关系，只要你过得了技术面。所以导致了现在什么都能转计算机，门槛实在是太低，你有台电脑就能学。这也是为什么我建议大家先选择自己喜欢的专业，实在混不下去了再转行绝对来得及&hellip;
建筑类和硬核工科类  中国的一大特点（优势？）就是培养工程师的成本低的离谱，所以一定程度上工科专业人才的待遇远不如国外的好。学机械的在国外叫做工程师，在国内就是天坑专业修机器的。这些行业的薪资虽然比不上互联网，但也没差到哪里去。如果喜欢的话就学吧，大不了混不下去了转互联网就是了。
基础学科物化生  其实还加上地理和半个数学之类的学科。这些要么以后就一直做科研，要么就做老师，要么就转行互联网。国内的生物啊化学啊之类的行业起步就是晚，不像互联网行业还能追，国家战略就没放在这些行业上，这些行业只要吊一口气不死就行了。如果是去药企啊，化工厂之类的，待遇是真的不行，至少是不够我优雅地生活的。我真的很喜欢基础学科，学着很快乐，如果你也一样就去学吧。做科研做老师都挺不错，虽然最近复旦青椒，我个人是很喜欢科研，很喜欢探寻宇宙奥秘物质本源的。打不了混不下去转行互联网就是了。
医学  学医就是当医生嘛。不过想学医要考虑好，医生是真大后期职业，别没憋到后期家就没了。学医不但要学很久，好像是要七八年的样子？拿主治之前还要规培专培各种培，等到真的当了医生之后各种值班不比996轻松，还有拿职称的压力，有些还有科研压力。这个跟金融经管类一样，要看家里资源够不够你拖到大后期吧。学医可能真的是学了就没回头路的。
师范类和文史类  师范就是当老师呗，一线城市中小学老师待遇是真不错，月入过万，过节各种福利，寒暑假，补习赚外快。在中学阶段一般数学老师地位要稍微高一些吧。文史类不太了解，应该也是做老师或科研吧。也可能转行互联网吧。
艺术类  也不了解，有同学学跳舞的，学美术的。美术的以后做设计啊什么应该都挺好的。唱歌跳舞的可能有艺术团，或者培训机构老师什么吧。大不了转行互联网嘛。
总结一下  可能考虑的不是很全，但意思是这么个意思。喜欢哪个就先去学，反正以后不一定是做对口的行业。特别是现在转行互联网的门槛这么这么低，国内的优秀程序员是真的缺，互联网行业随时可以来，错过了喜欢的专业就可能永远地错过了。哦对了，除了上面提到的，还有考公务员之类的选择。
 写完回来发现没提到学法律，心理学，警察之类的，累了不写了。
再讲回生涯规划  我问过身边的一些同学，以后想干什么，想要什么，想成为什么？很多人都没有一个明确的规划或目标，就老老实实做好现在该做的事，走一步看一步。我没有觉得这样不好，我觉得不好地方在于，很多想按部就班走一步看一步的人，是没有思考过自己想要什么，所以只能走一步看一步。如果你了解过，尝试过，探索过，得出了个结论：你现在确实没有非常喜欢做的事，所以你走一步看一步。那丝毫没有问题。
 生涯规划是什么？不是帮你规划好你一辈子要做什么，而是教会你要怎么去探索，去寻找你要做一辈子的事业。深中虽然有生涯教育，但是我觉得做的不是很好，也就是请外面的机构来搞了几个活动。连深中都做不好的事，我还能指望别的学校做好？
 而我前面也提到了，很多家长并不会和孩子讨论孩子的人生规划。隔壁邻居学钢琴了，我也把我家小孩送去学。孩子班里都报了数学补习班，我也赶紧报一个。家长很少和孩子讨论孩子喜欢什么，想做什么，这种情况可能会一直持续到高考填志愿。甚至有些人的高考志愿都是家长填的，然后工是家里人找的，然后相亲对象是家长找的&hellip;&hellip; 那还活个毛线？
 国内计算机专业现状  本来以为是自己学校的问题，后来才发现国内高校的计算机专业的普遍现状都是这样。课程教的和实际用的差距太大，课程要求学生写代码的量少得可怜，实验全是交word报告那种，你说离不离谱？我现在感觉就是，上课实在太耽误学习，实验课要花掉我一上午or一下午，还要水各种试验报告，我真的很想有时间啃一啃经典书，做一些国外lab。
 我真的见到太多，读了计算机专业，每天就跟着学校课程走，不知道学了个啥的同学。不用devc++，visual studio，eclipse就不会编译的同学也确实不少。课程设置的不合理是一部分原因，但主要是因为有很多同学跟风或不知道为啥选了计算机专业，又不知道怎么学，所以只跟着学校课程走。等到要找工作要面试时，才发现技术面试问的问题可能是课本里从未提到的。
 btw，计算机类专业不建议考研，除非是以后想做科研，或是本科四年读完才发现自己啥也不会，需要读研的时间补。大厂现在本科生和研究生入职的等级都没差了，研究生可谓是一点优势都没有。
 结语 最后再次强调，选自己喜欢的专业！！！
希望每个人都能找到自己喜欢的东西，朝着理想而努力。
peace</content></entry><entry><title>手撸一棵B树</title><url>https://yinanhong.site/post/btree/</url><categories><category>数据结构</category></categories><tags><tag>数据结构</tag><tag>B树</tag></tags><content type="html"> 本文教大家如何手撸一棵B树。
我在网上看到的大多数教程都是上来就丢给你一堆B树的性质特点，简直劝退，本文我会尝试用人能理解的思路介绍一下B树，有代码干货。
百度百科：
在计算机科学中，B树（英语：B-tree）是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。与自平衡二叉查找树不同，B树为系统大块数据的读写操作做了优化。B树减少定位记录时所经历的中间过程，从而加快存取速度。B树这种数据结构可以用来描述外部存储。这种数据结构常被应用在数据库和文件系统的实现上。
顺便，B树的英文是B-tree（B杠tree），有些人以为B树和B-树（B减树）是两回事，其实都是误会,并没有B减树。
 B树的构成和结构 B树的节点构成 上图展示的就是一棵b树。我们先来看看b树节点的组成。
b树的节点包含以下内容：
本节点存放的数据（关键字）数组（图中蓝底部分），编号从1开始 指向子节点的指针数组（图中白底部分） 指向父节点的指针（图中未标出）  下图红框框 框出来的就是一个节点。构建b树前需要先给出b树的阶数m，一个节点中最多有m-1个数据和m个子树。为了方便代码实现，我们规定关键字的编号从1开始，子节点的编号从0开始。
1 2 3 4 5 6 7 8 9 class BTNode { public: int keyNum; // 关键字个数 BTNode* parent; // 指向父节点 int* keys; // 关键字数组，编号从1开始 BTNode** ptr; // 子树指针数组 BTNode(); ~BTNode(); };  B树的数据存储结构 我们看存放32这个数据的节点。在节点内，数据从左到右是由小到大排列。
在32这个数据左侧的子树，其包含的所有数据都小于32，对于右侧的子树，其包含的数据都大于32。实际上每个节点都满足，节点内关键字由小到大排列，当前关键字左侧子树的关键字都小于当前关键字，右侧的则大于。
 B树的操作 B树常见的操作有，搜索，插入，分裂，删除/* todo */。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class BTree { private: BTNode* root; // 将k和ap分别插入t->key[i+1]和t->ptr[i + 1] void insert(BTNode* t, int i, int k, BTNode* ap); // 在p->key[1...keynum]中查找 k int search(BTNode* t, int k); // 将q->key[s+1...m],q->ptr[s...m]移入新结点ap void split(BTNode* q, int s, BTNode*&amp; ap); // 生成含信息(t, x, ap)的新根结点t*ap, 原t和 ap为子树指针 void newRoot(BTNode*&amp; t, BTNode* q, int x, BTNode* ap); // 在结点t的子结点q的key[i]与key[i+1]之间插入k void insertBT(BTNode*&amp; t, int k, BTNode* q, int i); Result searchBT(BTNode* t, int k); // 在结点t中查找k public: BTree(); ~BTree(); void insertBT(int key); // B-树插入操作 void searchBT(int key); // B-树查找操作 void levelOrder(); // B-树层次遍历 };  手撸一棵B树 讲具体的操作之前我们先手动实现一棵B树，这样方便大家理解B树的数据分布。B树的构建其实就是使用插入操作不断插入数据。给出一组数据21, 45, 65, 25, 31, 52, 55，构建3阶b树。
前面提到过，m阶b树的节点最多包含m-1个数据和m个子树，所以前三个数据只需按顺序插入到第一个节点。
插入第三个数据后，节点的数据超过了m-1=2个，这时候就需要对这个节点进行分裂操作。分裂的位置我们取m/2然后向上取整（可以有不同的取法），在这里就是第2个数据45。
分裂操作：
新建节点，将分裂位置右侧的全部数据移入新节点 分裂位置右侧的子树指针指向这个新结点 将分裂位置的数据和子树指针插入父节点，如果没有父节点则新建根节点  继续插入下一个数据25，从根节点进行搜索操作：
45 > 21，进入左子树搜索，21 &lt; 25，插入在右侧。同样地插入数据31。
 发现节点中数据超过2个，进行分裂，同样的分裂操作。
新建节点，将分裂位置右侧的全部数据移入新节点 分裂位置右侧的子树指针指向这个新结点 将分裂位置的数据和子树指针插入父节点，如果没有父节点则新建根节点 同样的道理插入最后两个数据，最后得到的数据结构是下图这样的（省略最后一层的空指针）。
 各位可以尝试手撸一下这个样例巩固一下。4阶b树，按顺序插入45, 24, 53, 90, 46, 47。
结果是这样的。
 搜索操作 传入根节点t和需要查询的关键字k，返回类Result。
tag为0或1表示是否查询成功。如果查询成功，pt为k所在的节点，i为k在pt中的位置。如果查询失败，pt为k需要插入的节点，i + 1为k插入的位置。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Result { public: BTNode* pt; // 指向找到的结点 int i; int tag; Result(BTNode* p, int m, int t) { pt = p; i = m; tag = t; } Result(const Result&amp; R) { pt = R.pt; i = R.i; tag = R.tag; } ~Result() { pt = nullptr; i = 0; tag = 0; } }; 从根结点开始搜索关键字k (line 17)
如果节点中存在>=k的关键字，则返回该关键字的前一个位置i - 1(line 5) 如果这个关键字==k (line 18)，则查询成功，返回节点信息(line 26) 如果这个关键字>k，查询失败，进入关键字左侧的子树搜寻(line 20)。如果子树不存在，则返回k的插入位置。 如果节点中不存在>=k的关键字，说明k比节点中所有关键字都大，所以返回最后一个子树指针的位置(line 8)，进入最右侧子树搜索(line 20) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 在p->key[1...keynum]中查找 k int BTree::search(BTNode* t, int k) { for (int i = 1; i &lt;= t->keyNum; i++) if (t->keys[i] >= k) return i - 1; //找到关键字>=k，如果=则找到，如果>则在左边的子树找，或在i处插入 return t->keyNum;//所有关键字都&lt;k，去最右侧边的子树找，或在keyNum处插入 } // 遍历所有节点查询key关键字 Result BTree::searchBT(BTNode* t, int k) { BTNode* p = t, * q = nullptr; // p指向当前查询节点，q指向当前节点的父节点 bool found = false; int i = 0; while (p &amp;&amp; !found) { i = search(p, k); // 在当前节点中查找k if (p->keys[i + 1] == k) found = true; else { q = p; p = p->ptr[i]; // 转到下一个节点 } } if (found) return Result(p, i + 1, 1); // 查找成功，返回节点信息 else return Result(q, i, 0); // 查找失败，返回插入位置信息 }  插入和分裂操作 传入key，在树中搜索key，如果返回的rusult.tag == 1，则关键字已存在，如果result.tag == 0，则执行插入操作。
1 2 3 4 5 6 7 // B-树插入操作 void BTree::insertBT(int key) { Result r = searchBT(root, key); if (!r.tag) { insertBT(root, key, r.pt, r.i); } } 将key插入节点的对应位置
插入后节点关键字数量 &lt; m - 1 ，插入成功，退出(line 14) 插入后节点关键字数量 > m - 1 ，执行分裂操作(line 16) 当前节点存在父节点，执行分裂操作③的插入父节点(line 21) 当前节点不存在父节点，执行分裂操作③的创建新根节点(line 23) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 void BTree::insertBT(BTNode*&amp; t, int k, BTNode* q, int i) { int x = k; BTNode* ap = nullptr; bool finished = false; if (!q) { // 创建第一个节点 q = new BTNode; q->keyNum = 1; q->keys[1] = k; this->root = q; return; } while (!finished) { insert(q, i, x, ap); // 将k和ap分别插入t->key[i+1]和t->ptr[i + 1] if (q->keyNum &lt; m) // 插入完成（keys从1开始，所以判断keyNum &lt; m） finished = true; else { // 分裂节点*q int s = (m + 1) / 2; // 向上取整 split(q, s, ap); // 将q->key[s+1...m],q->ptr[s...m]移入新结点ap x = q->keys[s]; q = q->parent; if (q) // 将ap插入父节点对应位置 i = search(q, x); //查找ap在父节点的插入位置 else { newRoot(t, q, x, ap); //创建新的根节点 finished = true; } } } } void BTree::split(BTNode* q, int s, BTNode*&amp; ap) { ap = new BTNode; int j = 1; // 将q->key[s+1...m],q->ptr[s...m]移入新结点ap for (int i = s + 1; i &lt;= q->keyNum; i++) { ap->keys[j] = q->keys[i]; ap->ptr[j] = q->ptr[i]; j++; } ap->ptr[0] = q->ptr[s]; ap->keyNum = j - 1; q->keyNum -= j; ap->parent = q->parent; for (int i = 0; i &lt;= ap->keyNum; i++) if (ap->ptr[i]) ap->ptr[i]->parent = ap; } // 生成含信息(t, x, ap)的新根结点t, 原t和 ap为子树指针 void BTree::newRoot(BTNode*&amp; t, BTNode* q, int x, BTNode* ap) { q = new BTNode; q->keyNum = 1; q->keys[1] = x; q->ptr[0] = t; q->ptr[1] = ap; t->parent = q; ap->parent = q; this->root = q; }  删除操作 todo
 完整代码和测试样例 输入 第一行输入t，表示有t个数据序列 第二行输入m, 表示要构建m阶B-树 第三行输入n，表示首个序列包含n个数据 第四行输入n个数据，都是自然数且互不相同，数据之间用空格隔开 输出 输出B-树的关键字 同一个结点的关键字之间用:间隔 不同结点之间的关键字用一个空格间隔 对B-树进行层次遍历可以得到。 样例输入 3 3 3 21 45 65 3 7 21 45 65 25 31 52 55 4 6 45 24 53 90 46 47 样例输出 45 21 65 45 25 55 21 31 52 65 45:47 24 46 53:90 代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 #include &lt;iostream>#include &lt;queue>using namespace std; int m; class BTNode { public: int keyNum; // 关键字个数 BTNode* parent; // 指向双亲结点 int* keys; // 关键字向量 BTNode** ptr; // 子树指针向量 BTNode() { keyNum = 0; parent = nullptr; keys = new int[m + 2]; ptr = new BTNode * [m + 2]; for (int i = 0; i &lt; m + 2; i++) ptr[i] = nullptr; } ~BTNode() { delete[] keys; delete[] ptr; } }; class Result { public: BTNode* pt; // 指向找到的结点 int i; int tag; Result(BTNode* p, int m, int t) { pt = p; i = m; tag = t; } Result(const Result&amp; R) { pt = R.pt; i = R.i; tag = R.tag; } ~Result() { pt = nullptr; i = 0; tag = 0; } }; class BTree { private: BTNode* root; void insert(BTNode* t, int i, int k, BTNode* ap); // 将k和ap分别插入t->key[i+1]和t->ptr[i + 1] int search(BTNode* t, int k); // 在p->key[1...keynum]中查找 k void split(BTNode* q, int s, BTNode*&amp; ap); // 将q->key[s+1...m],q->ptr[s...m]移入新结点ap void newRoot(BTNode*&amp; t, BTNode* q, int x, BTNode* ap); // 生成含信息(t, x, ap)的新根结点t*ap, 原t和 ap为子树指针 void insertBT(BTNode*&amp; t, int k, BTNode* q, int i); // 在结点t的子结点q的key[i]与key[i+1]之间插入k Result searchBT(BTNode* t, int k); // 在结点t中查找k public: BTree(); ~BTree(); void insertBT(int key); // B-树插入操作 void searchBT(int key); // B-树查找操作 void levelOrder(); // B-树层次遍历 }; // 将k和ap分别插入t->key[i+1]和t->ptr[i + 1] void BTree::insert(BTNode* t, int i, int k, BTNode* ap) { t->keyNum++; for (int j = t->keyNum; j > i + 1; j--) { //把[i+1, keyNum]的数据后移一位 t->keys[j] = t->keys[j - 1]; t->ptr[j] = t->ptr[j - 1]; } t->keys[i + 1] = k; //插入数据 t->ptr[i + 1] = ap; } // 在p->key[1...keynum]中查找 k int BTree::search(BTNode* t, int k) { for (int i = 1; i &lt;= t->keyNum; i++) if (t->keys[i] >= k) return i - 1; //找到关键字>=k，如果=则找到，如果>则在左边的子树找，或在i处插入 return t->keyNum; //所有关键字都&lt;k，去最右侧边的子树找，或在keyNum处插入 } // 将q->key[s+1...m],q->ptr[s...m]移入新结点ap void BTree::split(BTNode* q, int s, BTNode*&amp; ap) { ap = new BTNode; int j = 1; // 将q->key[s+1...m],q->ptr[s...m]移入新结点ap for (int i = s + 1; i &lt;= q->keyNum; i++) { ap->keys[j] = q->keys[i]; ap->ptr[j] = q->ptr[i]; j++; } ap->ptr[0] = q->ptr[s]; ap->keyNum = j - 1; q->keyNum -= j; ap->parent = q->parent; for (int i = 0; i &lt;= ap->keyNum; i++) if (ap->ptr[i]) ap->ptr[i]->parent = ap; } // 生成含信息(t, x, ap)的新根结点t, 原t和 ap为子树指针 void BTree::newRoot(BTNode*&amp; t, BTNode* q, int x, BTNode* ap) { q = new BTNode; q->keyNum = 1; q->keys[1] = x; q->ptr[0] = t; q->ptr[1] = ap; t->parent = q; ap->parent = q; this->root = q; } // 遍历所有节点查询key关键字 Result BTree::searchBT(BTNode* t, int k) { BTNode* p = t, * q = nullptr; // p指向当前查询节点，q指向当前节点的父节点 bool found = false; int i = 0; while (p &amp;&amp; !found) { i = search(p, k); // 在当前节点中查找k if (p->keys[i + 1] == k) found = true; else { q = p; p = p->ptr[i]; // 转到下一个节点 } } if (found) return Result(p, i + 1, 1); // 查找成功，返回节点信息 else return Result(q, i, 0); // 查找失败，返回插入位置信息 } // 参考课本244页算法9.14 void BTree::insertBT(BTNode*&amp; t, int k, BTNode* q, int i) { int x = k; BTNode* ap = nullptr; bool finished = false; if (!q) { // 创建第一个节点 q = new BTNode; q->keyNum = 1; q->keys[1] = k; this->root = q; return; } while (!finished) { insert(q, i, x, ap); // 将k和ap分别插入t->key[i+1]和t->ptr[i + 1] if (q->keyNum &lt; m) // 插入完成（keys从1开始，所以判断keyNum &lt; m） finished = true; else { // 分裂节点*q int s = (m + 1) / 2; // 向上取整 split(q, s, ap); // 将q->key[s+1...m],q->ptr[s...m]移入新结点ap x = q->keys[s]; q = q->parent; if (q) i = search(q, x); //查找在父节点的插入位置 else { newRoot(t, q, x, ap); finished = true; } } } } // B树初始化 BTree::BTree() { root = nullptr; } BTree::~BTree() { root = nullptr; } // B-树插入操作 void BTree::insertBT(int key) { Result r = searchBT(root, key); if (!r.tag) { insertBT(root, key, r.pt, r.i); } } // B-树查找操作 void BTree::searchBT(int key) { Result r = searchBT(root, key); if (!r.tag) { cout &lt;&lt; "-1" &lt;&lt; endl; } else { BTNode* p = r.pt; cout &lt;&lt; p->keys[1]; for (int i = 2; i &lt;= p->keyNum; i++) { cout &lt;&lt; ':' &lt;&lt; p->keys[i]; } cout &lt;&lt; ' ' &lt;&lt; r.i &lt;&lt; endl; } return; } // B-树层次遍历输出关键字 void BTree::levelOrder() { queue&lt;BTNode*> tq; BTNode* p = root; // 首结点入队 if (p) { tq.push(p); } // 层次遍历树 while (!tq.empty()) { p = tq.front(); tq.pop(); // 输出结点p的key cout &lt;&lt; p->keys[1]; for (int i = 2; i &lt;= p->keyNum; i++) { cout &lt;&lt; ':' &lt;&lt; p->keys[i]; } cout &lt;&lt; ' '; // 自结点入栈 for (int i = 0; i &lt;= p->keyNum; i++) { if (!p->ptr[i]) { break; } tq.push(p->ptr[i]); } } return; } int main(void) { int t; cin >> t; while (t--) { cin >> m; int n, k, key; // 构建B-树 cin >> n; BTree bTree; while (n--) { cin >> key; bTree.insertBT(key); } // 按层次遍历输出B-树 bTree.levelOrder(); cout &lt;&lt; endl; // 查找B-树结点 //cin >> k; //while (k--) { // cin >> key; // bTree.searchBT(key); //} } return 0; } 参考资料 https://www.yiibai.com/data_structure/b-tree.html
https://blog.csdn.net/alzzw/article/details/97663352
《数据结构（C语言版）》清华大学出版社
  </content></entry><entry><title>基于TCP协议的简易通讯程序</title><url>https://yinanhong.site/post/fakeqq/</url><categories><category>小玩意</category></categories><tags><tag>Java</tag><tag>网络编程</tag><tag>TCP</tag></tags><content type="html"> Java课网络编程部分的一个小练习，用Socket类和ServerSocket类进行TCP编程，做一个简易的带图形界面的聊天工具。
Java课教的比较简单，风格是那种什么都讲一点，又什么都讲的很浅的那种。不过老师写了这本教材还是很不容易的，入门的初初学者可以用来当字典型的书了。
书上给了个Server、Client对话程序的例子，不过是很简单的在命令行显示，然后用终端输入来卡循环，所以只能一人发一句。
课本源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 // 客户端程序 package sample; import java.io.*; import java.net.*; public class TalkClient { public static void main(String args[]) { try{ Socket socket=new Socket("127.0.0.1",4700); //向本机的4700端口发出客户请求 BufferedReader sin=new BufferedReader(new InputStreamReader(System.in)); //由系统标准输入设备构造BufferedReader对象 PrintWriter os=new PrintWriter(socket.getOutputStream()); //由Socket对象得到输出流，并构造PrintWriter对象 BufferedReader is=new BufferedReader( new InputStreamReader(socket.getInputStream())); //由Socket对象得到输入流，并构造相应的BufferedReader对象 String readline; readline=sin.readLine(); //从系统标准输入读入一字符串 while(!readline.equals("bye")){ //若从标准输入读入的字符串为 "bye"则停止循环 os.println(readline); //将从系统标准输入读入的字符串输出到Server os.flush(); //刷新输出流，使Server马上收到该字符串 System.out.println("Client:"+readline); //在系统标准输出上打印读入的字符串 System.out.println("Server:"+is.readLine()); //从Server读入一字符串，并打印到标准输出上 readline=sin.readLine(); //从系统标准输入读入一字符串 } os.close(); //关闭Socket输出流 is.close(); //关闭Socket输入流 socket.close(); //关闭Socket }catch(Exception e) { System.out.println("Error"+e); //出错，则打印出错信息 } } } // 服务器端程序 package sample; import java.io.*; import java.net.*; import java.applet.Applet; public class TalkServer{ public static void main(String args[]) { try{ ServerSocket server=null; try{ //新建4700端口的服务端 server=new ServerSocket(4700); }catch(Exception e) { System.out.println("can not listen to:"+e); //出现异常则返回信息 } Socket socket=null; try{ socket=server.accept(); //连接客户端 }catch(Exception e) { System.out.println("Error."+e); //出现异常返回信息 } String line; BufferedReader is=new BufferedReader( new InputStreamReader(socket.getInputStream())); //由系统标准输入设备构造BufferedReader对象 PrintWriter os=new PrintWriter(socket.getOutputStream()); //由Socket对象得到输出流，并构造PrintWriter对象 BufferedReader sin=new BufferedReader(new InputStreamReader(System.in)); //由Socket对象得到输入流，并构造相应的BufferedReader对象 System.out.println("Client:"+is.readLine()); //从Client读入一字符串，并打印到标准输出上 line=sin.readLine(); //从系统标准输入读入字符串 while(!line.equals("bye")){ //若从标准输入读入的字符串为 "bye"则停止循环 os.println(line); //将从系统标准输入读入的字符串输出到Client os.flush(); //刷新输出流，使Server马上收到该字符串 System.out.println("Server:"+line); //在系统标准输出上打印读入的字符串 System.out.println("Client:"+is.readLine()); //从Server读入一字符串，并打印到标准输出上 line=sin.readLine(); //从系统标准输入读入一字符串 } os.close(); //关闭Socket输出流 is.close(); //关闭Socket输入流 socket.close(); //关闭Socket server.close(); //关闭ServerSocket }catch(Exception e){ System.out.println("Error:"+e); //捕获异常，输出错误信息 } } } 优化 我就简单改了下加了个线程，让它可以连续发送和接收。发送的线程50ms刷新一次，等发送信号（不设延时的话循环会跑的飞快，更改发送信号的线程没反应&hellip;）。接收消息的函数是会等待消息收到才会继续运行，就不用手动卡时间了。
图形界面是网上找的，删删改改了一下。
注释非常详尽，直接看源码吧~
精分现场简直笑死，再也不说编程没意思了hhhhh
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 import java.io.*; import java.net.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.text.SimpleDateFormat; import java.util.Date; import javax.swing.*; import java.util.*; //图形界面 class Chat extends JFrame implements ActionListener { static boolean status = true; static boolean send = false; private JLabel label1, label2; private JTextField jTextField2; // 文本框 private JButton button2, button3; // 按钮 private JTextArea textArea; // 文本域 private JPanel southPanel; // 面板 // 日期格式化 ，后面接收消息方法receive会用到 private static SimpleDateFormat sdf2 = new SimpleDateFormat("a HH:mm:ss"); public Chat() { // 定义窗口宽高常量 final int width = 500; final int height = 600; // 获取屏幕尺寸 Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize(); JFrame myJFrame = new JFrame("Fake QQ"); // 设置窗口大小 myJFrame.setSize(width, height); // 设置窗口居中显示 myJFrame.setLocation(screenSize.width / 2 - width / 2, screenSize.height / 2 - height / 2); // 网格布局 this.setLayout(new BorderLayout()); label1 = new JLabel("SERVER", SwingConstants.RIGHT); //窗口顶部名称 JPanel innerPanelCenter = new JPanel(); JPanel innerPanel = new JPanel(); innerPanel.add(label1); innerPanelCenter.add(innerPanel); label2 = new JLabel("快开始聊天吧!"); label2.setForeground(Color.red); label2.setBorder(BorderFactory.createTitledBorder("提示")); JPanel northPanel = new JPanel(new BorderLayout()); northPanel.add(innerPanelCenter, BorderLayout.CENTER); northPanel.add(label2, BorderLayout.SOUTH); myJFrame.add(northPanel, BorderLayout.NORTH); textArea = new JTextArea(); textArea.setLineWrap(true); textArea.setWrapStyleWord(true); textArea.setFont(new Font("幼圆", Font.PLAIN, 16)); myJFrame.add(new JScrollPane(textArea), BorderLayout.CENTER); southPanel = new JPanel(); southPanel.add(new JLabel()); jTextField2 = new JTextField(30); southPanel.add(jTextField2); button2 = new JButton("发送"); southPanel.add(button2); button3 = new JButton("退出"); southPanel.add(button3); button2.addActionListener(this); button3.addActionListener(this); myJFrame.add(southPanel, BorderLayout.SOUTH); // 设置窗口可见 myJFrame.setVisible(true); } public void actionPerformed(ActionEvent e) { if (e.getSource() == button2) { send(); // 发送 } if (e.getSource() == button3) { status = false; System.exit(0); // 退出 } } public void send() { // 设置发送信号 send = true; } public void onscreen(String person, String str) { // 图形界面输出 textArea.append((sdf2.format(new Date())) + "\n" + person + ": " + str + "\n\n"); } public String getText() { String str = jTextField2.getText(); jTextField2.setText(""); // 清空输入栏 return str; } } // 服务端 public class TalkServer { public static void main(String args[]) { try { Chat chat = new Chat(); // 创建图形界面实例 ServerSocket server = null; // 创建socket try { server = new ServerSocket(4701); } catch (Exception e) { System.out.println("can not listen to:" + e); } Socket socket = null; try { socket = server.accept(); // 等待客户端接入 } catch (Exception e) { System.out.println("Error." + e); } PrintWriter os = new PrintWriter(socket.getOutputStream()); BufferedReader is = new BufferedReader(new InputStreamReader(socket.getInputStream())); class Send extends Thread { // 发送线程 public void run() { os.println("connected"); os.flush(); String str = null; while (Chat.status) { // status由图形界面关闭按钮控制 System.out.println("waiting to send"); // 命令行输出状态 while (!Chat.send) { // 等待发送信号 try { Thread.sleep(50); // 每50ms刷新状态 } catch (InterruptedException e) { e.printStackTrace(); } } Chat.send = false; // 重置等待信号 str = chat.getText(); // 获取发送框文本 chat.onscreen("You", str); // 显示发送内容 try { os.println(str); // 发送 os.flush(); } catch (Exception e) { System.out.println("Sending error." + e); } } } } Send SendingThread = new Send(); // 创建并启动线程 SendingThread.start(); // 接收设在主线程，**不知道为什么创建新线程is.readLine()会出现异常** String str; while (Chat.status) { System.out.println("waiting to receive"); // 命令行输出状态 str = is.readLine(); // 等待接收 System.out.println("Client:" + str); // 命令行显示接收内容 chat.onscreen("Client", str); // 图形界面显示接收内容 } os.close(); // 关闭Socket输出流 is.close();// 关闭Socket输入流 socket.close(); // 关闭Socket server.close(); } catch (IOException e) { e.printStackTrace(); System.out.println("error"); } } } // 客户端 public class TalkClient { public static void main(String args[]) { try { Chat chat = new Chat(); // 创建图形界面实例 System.out.println("111"); Socket socket = new Socket("127.0.0.1", 4701); // 创建socket，接入终端 PrintWriter os = new PrintWriter(socket.getOutputStream()); BufferedReader is = new BufferedReader(new InputStreamReader(socket.getInputStream())); class Send extends Thread { // 发送线程 public void run() { os.println("connected"); os.flush(); String str = null; while (Chat.status) { // status由图形界面关闭按钮控制 System.out.println("waiting to send"); // 命令行输出状态 while (!Chat.send) { // 等待发送信号 try { Thread.sleep(50); // 每50ms刷新状态 } catch (InterruptedException e) { e.printStackTrace(); } } Chat.send = false; // 重置等待信号 str = chat.getText(); // 获取发送框文本 chat.onscreen("You", str); // 显示发送内容 try { os.println(str); // 发送 os.flush(); } catch (Exception e) { System.out.println("Sending error." + e); } } } } Send SendingThread = new Send(); // 创建并启动线程 SendingThread.start(); // 接收设在主线程，**不知道为什么创建新线程is.readLine()会出现异常** String str; while (Chat.status) { System.out.println("waiting to Receive"); // 命令行输出状态 str = is.readLine(); // 等待接收 System.out.println("Server:" + str); // 显示接受内容 chat.onscreen("Server", str); // 图形界面显示接收内容 } os.close(); // 关闭Socket输出流 is.close();// 关闭Socket输入流 socket.close(); // 关闭Socket } catch (IOException e) { e.printStackTrace(); System.out.println("error"); } } }</content></entry><entry><title>微信图片dat格式解码</title><url>https://yinanhong.site/post/wechatpicdecrypt/</url><categories><category>小工具</category></categories><tags><tag>图片解码</tag></tags><content type="html"> PC端微信会把图片保存为.dat格式，实际上是对图片的16进制编码进行了简单的异或加密。本文简单分析一下加密原理，然后提供一个常见图片格式解码的python实现。
问题背景 事情是这样的&hellip;
有一天想找一个远古聊天记录里的照片，因为我换了手机，所以只能在pc端慢慢往上翻到去年的记录&hellip; 于是我就想，图片肯定会存在本地的呀，打开文件发现微信保存的格式是没见过的.dat，于是我打开了百度&hellip;
其实下面讲的原理和方法都是参考了网上dalao们发过的，我就是整合了一下，代码优化了下，加了点细节，然后又可以水一篇文章哈哈哈。
太长不看版 对于没有编程能力或者对原理不感兴趣的同学，我贴心地封装了可执行文件，下载下来就可以直接运行了。
Yinan-Hong/WechatPicDecrypt (github.com)
GG，因为调用了os库，所以封装的可执行文件会被windows当成木马查杀。要怎么解决我有空再搞吧我要睡觉了&hellip;. QwQ
// todo
微信的文件存储 PC端的微信，点开后的图片会被下载到本地，没点开的只会存高糊的预览图。微信的文件会存储在你设定的文件夹里，默认是在C盘安装微信的位置，可以在微信左下角【设置】→【文件管理】查看文件存储目录。
打开目录下名为【WeChat Files】的目录，里面会有以【微信号】命名的目录，里面存的就是这个微信号的聊天文件，包括文本，发送的文件，图片，表情包之类的。进入【FileStorage】→【Image】，里面是按月份分的聊天记录内下载过的图片。文件是后缀是.dat格式，只有在客户端用微信自带的图片查看器才能正常打开。
加密原理 用16进制编辑器打开dat文件，发现每个文件的前几个字节都是一样的。因为jpg、png文件开头都是固定的，比如jpg文件第一个字节是0xFF, 0xD8，所以猜测这个加密方式是对每个字节用密码进行异或。
将文件前两个字节0x07, 0x20与jpg文件的前两个字节0xFF, 0xD8进行异或
运算结果都为0xF8，所以猜测加密密码是0xF8。也就是说这个是将文件的每个字节与0xF8异或，然后将文件保存为.dat后缀的文件。实际上这个文件就是这样加密的，只是每个用户的加密密码是不一样的。
解码程序思路 首先要输入文件夹的绝对地址，然后遍历里面的每一个文件。
因为发现目录下可能有些其他格式的配置文件，所以判断一下文件后缀不是.dat的跳过。
对dat文件，分别取jpg，png，gif（这三个格式比较常见，所以只做了这三个的）的前两个字节，【文件的第一个字节】与【jpg的第一个字节】异或得到【十六进制数1】，【文件的第二个字节】与【jpg的第二个字节】异或得到两位【十六进制数2】。如果得到的【十六进制数1】等于【十六进制数2】，那就能判断原文件的格式是jpg，并且得到了加密密码就是【十六进制数1】。
同样的道理判断文件出的格式，得到密码后，将文件解码，保存为.jpg文件，然后输出到目录下名为output的文件夹。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 import os ''' jpg文件的第一个字节为 pic_head[0], pic_head[1] png为[2],[3] gif为[4],[5] ''' pic_head = [0xff, 0xd8, 0x89, 0x50, 0x47, 0x49] decode_code = 0 # 解密码 #判断文件类型，并获取dat文件解密码 def get_code(file_path): # file_path: dat文件路径 dat_file = open(file_path, "rb") dat_read = dat_file.read(2) head_index = 0 while head_index &lt; len(pic_head): #使用第一个头信息字节来计算加密码 code = dat_read[0] ^ pic_head[head_index] idf_code = dat_read[1] ^ code head_index = head_index + 1 #第二个字节来验证解密码是否正确 if idf_code == pic_head[head_index]: dat_file.close() return code head_index = head_index + 1 #如果解码成功，则返回解密码，如果文件不是这三种格式则返回0 print("not jpg, png, gif") return 0 def decrypt(file_name, file_path, output_file): #dat文件路径，生成文件路径 #获取密码 decode_code = get_code(file_path) dat_file = open(file_path, "rb") pic_name = output_file + ".jpg" pic_write = open(pic_name, "wb") #解码 for dat_data in dat_file: for dat_byte in dat_data: pic_data = dat_byte ^ decode_code pic_write.write(bytes([pic_data])) print(file_name + "---解码成功") dat_file.close() pic_write.close() def mkdir(path): path=path.strip() # 去除尾部 \ 符号 path=path.rstrip("\\") # 判断路径是否存在 isExists=os.path.exists(path) if not isExists: # 如果不存在则创建目录 # 创建目录操作函数 os.makedirs(path) print (path + ' 目录创建成功') return True else: # 如果目录存在则不创建，并提示目录已存在 print (path + ' 目录已存在') return False def find_datfile(dir_path): #获取dat文件目录下所有的文件 files_list = os.listdir(dir_path) output_path = dir_path + "\output" #在原目录下新建一个output目录 mkdir(output_path) cnt = 0 succeed = 0 #对每个文件获取文件名然后解码 for file_name in files_list: #判断文件后缀是否为.dat cnt = cnt + 1 file_type = file_name[-4:] if(file_type!=".dat"): print(file_name + '---文件不是.dat格式') continue file_path = dir_path + "\\" + file_name output_file = output_path + "\\" +file_name decrypt(file_name, file_path, output_file) succeed = succeed + 1 print("==================") print("All done!") print ("目录下文件共", cnt, "个，成功解码", succeed, "个。") print("==================") path = input("请输入微信dat文件的目录（绝对路径）:") find_datfile(path) 运行示例 运行前的文件夹，有三个.dat文件，有一个不是
运行程序
输入目录路径
运行后的文件夹
写在最后 其实这个是大半年前遇到的问题，当时网上搜到了比较方便的在线解码器。但是那时候想想，都学计算机了，要不试试像程序员一样去解决问题，于是就搜了更多方法。
本文的内容参考了一些博客，只要搜微信dat文件之类的关键词就能搜到很多，不少人很早之前就遇到并解决了这个问题。不过这是我第一次用编程的方法解决我遇到的实际问题，感觉非常有纪念意义，值得写这么一篇东西记录一下哈哈。</content></entry><entry><title>关于我</title><url>https://yinanhong.site/about.html</url><categories/><tags/><content type="html"> 年级 大二在读
教育经历 深圳中学2019届
深圳技术大学物联网工程2023届
学习方向 C/C++后台开发
游戏开发
爱好 唱歌、弹琴、吉他、美剧、漫威（资深漫威粉）、王者荣耀
梦想 世界和平
小目标 去腾讯开发王者荣耀
长得 很帅
本站介绍 有一天心血来潮，想做个网站放放自己的作品和学习经历什么的，也方便我35岁失业后转行搞自媒体。于是五一捣鼓了一天弄出了这么个东西，感谢上一位优化这个主题的dalao慷慨开源。
网站用到的技术 本站用的是一个叫Hugo的静态网页生成工具，据说是用Go语言写的，所以理论上比大家常用的一些Hexo之类的可能速度要快一点，但比较小众所以功能可能有些不太全，出了问题只能上英文网站查&hellip;
网站主题用的是Next，很简洁很苹果，我很喜欢。Anyway，页面最下方有指向Hugo和next主题的链接，左侧sidebar有优化这个主题的github，有兴趣的朋友可以自行了解下。等我捣鼓明白了再写一篇关于制作个人主页的教程。
关于我 我是万万没想到会学计算机方向的，我喜欢的是生物，但家里没矿学不起。因为高考考了个很尴尬的分，种种考虑下还是到了深技大的物联网专业。
上大学之前我是完完全全没有接触过编程方面的知识的，硬要说有就是高中的电脑课教过c++，但那个课是教三样东西（另外两个是pr和产品设计），取成绩最好的两项算成绩。反正当时考试敲个算闰年的程序，我愣是一行都没敲出来，然后旁边的文科生朋友很快就写完了&hellip;. 所以说程序语言应该算语言学&hellip;
Anyway&hellip; 我感觉学校对我们专业的定位不是很明确，然后需要花大量时间学硬件相关的课程，我按学校的学习进度应该会比同期的计算机专业的同学要慢上不少，而且乱上不少。我在学习的时候，时常会遇到一些比入门问题要难一点，但是也没难到哪里去的问题。周围很少有能一起讨论的同学，所以我总是会在一些很蠢的问题上卡很长时间。
关于本站的文章 所以我打算写一些技术文章，记录一下学习过程中遇到过的比较难的知识or技术。然后这学期在上数据结构与算法，如果做到什么有意思的题目，或者我有什么清奇的思路，也会写一篇题解之类的文章。
我目前的水平也就这样了，我会尽量把我搞懂了的东西写清楚，希望能帮到比我菜的同学。等以后我牛逼了一定会写更多有技术含量的文章来回馈开源社区！
除了编程相关之外，我还会写一些键政文章。我觉得中国的教育缺失对学生社会责任感的培养，作为社会中的一个个体，我们应该承担自己的社会责任，要有推动社会进步的意识。我很幸运在深圳中学遇到了很多有思想，有担当的青年同学和教师。在ta们的影响下我开始关注时事，并乐于分享自己的思考。说白了就是，学什么都救不了中国人，所以我只能拿起手中的键盘&hellip;</content></entry><entry><title>最优二叉树和赫夫曼编码</title><url>https://yinanhong.site/post/huffmantree/</url><categories><category>算法</category><category>数据结构</category></categories><tags><tag>最优二叉树</tag><tag>二叉树</tag><tag>算法</tag></tags><content type="html"> 节点的带权路径长度是指根节点到该节点的路径长度与节点权值的乘积。最优二叉树（赫夫曼树or哈夫曼树）是指带权路径和最小的二叉树。构建赫夫曼树时，要使带权路径和最小，需要遵循权重大的节点离根节点更近。
构建赫夫曼树 有给定权值的n个节点：
在n个节点中选出两个权值最小的节点，将两个节点组成一个二叉树，根结点的权值为左右子节点权值的和。
将上一步的根节点放入剩下的节点中，进行 1 。
赫夫曼编码 问题： 请设计变长的前缀码，对消息DEAACAAAAABA进行编码
对消息DEAACAAAAABA进行编码的前缀码编码方案很多，比如用ascii码之类的但是会很长因，因为每个字母的ascii码都要占1个byte。
消息中字符 A 出现了8次，字符 B、C、D 和 E 均只出现了1次；字符 A 用一个bit位表示，A=0，其他字符的编码均不能以0开头；
B=10、C=11、D=110和 E=111
DEAACAAAAABA=110111001100000100。这样得到比较短的编码。
编码规则 原文链接：哈夫曼编码详解——图解真能看了秒懂_Young_IT的博客-CSDN博客
直接上题目: 已知字符集 { a, b, c, d, e, f }，
若各字符出现的次数分别为{ 6, 3, 8, 2, 10, 4 }，
则对应字符集中各字符的哈夫曼编码可能是：(2分)
A. 00, 1011, 01, 1010, 11, 100
B. 00, 100, 110, 000, 0010, 01
C. 10, 1011, 11, 0011, 00, 010
D. 0011, 10, 11, 0010, 01, 000
步骤一： 1.找最小两个次数（这里是2和3）
2.把他们放进树中（小左大右）
3.每次组合都多一个父节点（即2+3=5）
步骤二： 1.再选出2个最小的数（排除上面已经选了的）——选出了4和6
2.因为4&lt;5 , 6>5（5为步骤一中组合后的父节点）
3.单独拿4来跟5组合（小左大右） 【如果拿出的2个数都比5小，则这2个数自己组合后跟5组合，下面提到】
####　步骤三： 1.因为步骤二用掉了4，还没用6。现在取最小2个数
2.因为6 &lt; 9 , 8&lt; 9 所以6和8自己组合（小左大右） （组合后先放一边）
步骤四： 1.取出最后10
2.10要和这两个子树根节点最小的组合（9&lt;14,所以和9组合）（小左大右）
3.然后把14的子树组合上去（小左大右） 所以放左边
步骤五： 组合完哈夫曼树后,将对应的字符填上去
步骤六： 从根节点开始向下走往左为0，往右1。走到对应的字符的路径就是该字符的哈夫曼编码（左0右1）
最后结果： 字符 赫夫曼编码 a 00 b 1011 c 01 d 1010 e 11 f 100 所以最后答案 A
已知字符集{ a, b, c, d, e, f }，
若各字符出现的次数分别为{ 6, 3, 8, 2, 10, 4 }，
则对应字符集中各字符的哈夫曼编码可能是：(2分)
A. 00, 1011, 01, 1010, 11, 100 ✔
B. 00, 100, 110, 000, 0010, 01
C. 10, 1011, 11, 0011, 00, 010
D. 0011, 10, 11, 0010, 01, 000
版权声明：本文为CSDN博主「Young_IT」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/Young_IT/article/details/106730343
参考代码 输入 第一行输入t，表示有t个测试实例 第二行先输入n，表示第1个实例有n个权值，接着输入n个权值，权值全是小于1万的正整数 依此类推
输出 逐行输出每个权值对应的编码，格式如下：权值-编码 即每行先输出1个权值，再输出一个短划线，再输出对应编码，接着下一行输入下一个权值和编码。 以此类推
样例输入 1
5 15 4 4 3 2
样例输出 15-1
4-010
4-011
3-001
2-000
实现代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 const int MaxW = 9999999; // 假设结点权值不超过9999999 // 定义huffman树结点类 class HuffNode { public: int weight; // 权值 int parent; // 父结点下标 int leftchild; // 左孩子下标 int rightchild; // 右孩子下标 }; // 定义赫夫曼树类 class HuffMan { private: void MakeTree(); // 建树，私有函数，被公有函数调用 void SelectMin(int pos, int* s1, int* s2); // 从 1 到 pos 的位置找出权值最小的两个结点，把结点下标存在 s1 和 s2 中 public: int len; // 结点数量 int lnum; // 叶子数量 HuffNode* huffTree; // 赫夫曼树，用数组表示 string* huffCode; // 每个字符对应的赫夫曼编码 void MakeTree(int n, int wt[]); // 公有函数，被主函数main调用 void Coding(); // 公有函数，被主函数main调用 void Destroy(); }; // 构建huffman树 void HuffMan::MakeTree(int n, int wt[]) { // 参数是叶子结点数量和叶子权值 // 公有函数，对外接口 int i; lnum = n; len = 2 * n - 1; huffTree = new HuffNode[2 * n]; huffCode = new string[lnum + 1]; // 位置从 1 开始计算 // huffCode实质是个二维字符数组，第 i 行表示第 i 个字符对应的编码 // 赫夫曼树huffTree初始化 for (i = 1; i &lt;= n; i++) huffTree[i].weight = wt[i - 1]; // 第0号不用，从1开始编号 for (i = 1; i &lt;= len; i++) { if (i > n) huffTree[i].weight = 0; // 前n个结点是叶子，已经设置 huffTree[i].parent = 0; huffTree[i].leftchild = 0; huffTree[i].rightchild = 0; } MakeTree(); // 调用私有函数建树 } void HuffMan::SelectMin(int pos, int* s1, int* s2) { // 找出最小的两个权值的下标 // 函数采用地址传递的方法，找出两个下标保存在 s1 和 s2 中 int w1, w2, i; w1 = w2 = MaxW; // 初始化w1和w2为最大值，在比较中会被实际的权值替换 *s1 = *s2 = 0; for (i = 1; i &lt;= pos; i++) { // 比较过程如下： // 如果第 i 个结点的权值小于 w1，且第 i 个结点是未选择的结点，提示：如果第 i 结点未选择，它父亲为 0 // 把第 w1 和 s1 保存到 w2 和 s2，即原来的第一最小值变成第二最小值 // 把第 i 结点的权值和下标保存到 w1 和 s1，作为第一最小值 // 否则，如果第 i 结点的权值小于 w2，且第 i 结点是未选择的结点 // 把第 i 结点的权值和下标保存到 w2 和 s2，作为第二最小值 if (w1 > huffTree[i].weight &amp;&amp; !huffTree[i].parent) { w2 = w1; *s2 = *s1; w1 = huffTree[i].weight; *s1 = i; } else if (w2 > huffTree[i].weight &amp;&amp; !huffTree[i].parent) { w2 = huffTree[i].weight; *s2 = i; } } } void HuffMan::MakeTree() { // 私有函数，被公有函数调用 int i, s1, s2; for (i = lnum + 1; i &lt;= len; i++) { SelectMin(i - 1, &amp;s1, &amp;s2); // 找出两个最小权值的下标放入 s1 和 s2 中 huffTree[s1].parent = huffTree[s2].parent = i; huffTree[i].leftchild = s1; huffTree[i].rightchild = s2; huffTree[i].weight = huffTree[s1].weight + huffTree[s2].weight; // 将找出的两棵权值最小的子树合并为一棵子树，过程包括 // 结点 s1 和结点 s2 的父亲设为 i // 结点 i 的左右孩子分别设为 s1 和 s2 // 结点 i 的权值等于 s1 和 s2 的权值和 } } // 赫夫曼编码 void HuffMan::Coding() { char* cd; int i, c, f, start; // 求 n 个结点的赫夫曼编码 cd = new char[lnum]; // 分配求编码的工作空间 cd[lnum - 1] = '\0'; // 编码结束符 for (i = 1; i &lt;= lnum; ++i) { // 逐个字符求赫夫曼编码 start = lnum - 1; // 编码结束符位置 // 参考课本P147算法6.12 HuffmanCoding代码 for (c = i, f = huffTree[i].parent; f != 0; c = f, f = huffTree[f].parent) if (huffTree[f].leftchild == c) cd[--start] = '0'; else cd[--start] = '1'; huffCode[i].assign(&amp;cd[start]); // 把cd中从start到末尾的编码复制到huffCode中 } delete[]cd; // 释放工作空间 } // 销毁赫夫曼树 void HuffMan::Destroy() { len = 0; lnum = 0; delete[]huffTree; delete[]huffCode; } // 主函数 int main() { int t, n, i, j; int wt[800]; cin >> t; HuffMan myHuff; for (i = 0; i &lt; t; i++) { cin >> n; for (j = 0; j &lt; n; j++) cin >> wt[j]; myHuff.MakeTree(n, wt); myHuff.Coding(); for (j = 1; j &lt;= n; j++) { cout &lt;&lt; myHuff.huffTree[j].weight &lt;&lt; '-'; // 输出各权值 cout &lt;&lt; myHuff.huffCode[j] &lt;&lt; endl; // 输出各编码 } myHuff.Destroy(); } return 0; } 解码参考代码 输入 第一行输入t，表示有t个测试实例 第二行先输入n，表示第1个实例有n个权值，接着输入n个权值，权值全是小于1万的正整数 第三行输入n个字母，表示与权值对应的字符 第四行输入k，表示要输入k个编码串 第五行起输入k个编码串 以此类推输入下一个示例
输出 每行输出解码后的字符串，如果解码失败直接输出字符串“error”，不要输出部分解码结果
样例输入 2
5 15 4 4 3 2
A B C D E
3
11111
10100001001
00000101100
4 7 5 2 4
A B C D
3
1010000
111011
111110111
样例输出 AAAAA
ABEAD
error
BBAAA
error
DCD
实现代码 只需在上文赫夫曼树实现代码中加入 Coding 方法和 Decoding 方法的实现。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 //解码方法 int HuffMan::Decode(const string codestr, char txtstr[]) { int i, k, c; char ch; c = len; k = 0; for (i = 0; i &lt; codestr.length(); i++) { ch = codestr[i]; if (ch == '0') { c = huffTree[c].leftchild; } else if (ch == '1') { c = huffTree[c].rightchild; } else { return -1; } if (huffTree[c].leftchild == 0 &amp;&amp; huffTree[c].rightchild == 0) { txtstr[k++] = huffTree[c].cha; c = len; } else { ch = '\0'; } } if (ch == '\0') return -1; else txtstr[k] = '\0'; return 1; } //主函数 int main() { int t, n, i, j, m; int wt[800]; char ct[800]; HuffMan myHuff; cin >> t; for (i = 0; i &lt; t; i++) { cin >> n; string codestr; char txtstr[800]; for (j = 0; j &lt; n; j++) { cin >> wt[j]; } for (j = 0; j &lt; n; j++) { cin >> ct[j]; } myHuff.MakeTree(n, wt, ct); myHuff.Coding(); cin >> m; while (m--) { cin >> codestr; if (myHuff.Decode(codestr, txtstr) == 1) { cout &lt;&lt; txtstr &lt;&lt; endl; } else { cout &lt;&lt; "error" &lt;&lt; endl; } } myHuff.Destroy(); } return 0; } 一道算法题 赫夫曼编码长度 题目描述 每行一个大小写英文字母组成的字符串，长度不大于 1000，通过前缀编码后最短的编码长度。
输入 第一行输入一个整数t，表示有t组测试数据；
接下来输入t组测试数据，每组数据一行，大小写英文字母。
输出 每组数据输出赫夫曼编码长度
样例输入 4
AABBCCDEEEE
AAABCCC
BBACB
tPvlQHFbPN
样例输出 25
11
7
32
题目解析 ` 本题如果真要用哈夫曼来建树，计算值会非常复杂。
首先要能够发现规律：哈夫曼树的编码长度等于各个叶节点权值与路径长度乘积之和，同时这个值等于非叶节点之和。
采用优先队列模拟哈夫曼树的建立。采用map记录字符与出现的次数，将每个字符的次数依次加入优先队列（数值小的在队头），每一次从队列中出队最小的两个，相加后再加入队列中。用ans记录每一次相加和temp值之和，当队列中剩下一个元素时，ans的值即为所求
知识点： priority_queue 优先队列：
priority_queue&lt;int>q; 默认为数字（字典序）大的值在队首top，等价于priority_queue&lt;int, vector&lt;int>, less&lt;int> >q;
priority_queue&lt;int, vector&lt;int>, greater&lt;int> >q; 表示数字（字典序）小的在队首
版权声明：本文为CSDN博主「julia7_」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_35093872/article/details/88055475
AC代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include &lt;iostream>#include &lt;string>#include &lt;cstring>#include &lt;queue>#include &lt;map>using namespace std; const int maxn = 100; int main() { int t; cin >> t; while (t--) { string str; map&lt;char, int> mp; priority_queue&lt;int, vector&lt;int>, greater&lt;int> >q; cin >> str; int len = str.length(); for (int i = 0; i &lt; len; i++) { if (mp.find(str[i]) == mp.end()) { mp[str[i]] = 1; } else { mp[str[i]]++; } } for (map&lt;char, int>::iterator it = mp.begin(); it != mp.end(); it++) { q.push(it->second); } int ans = 0; while (q.size() != 1) { int a, b, temp; a = q.top(); q.pop(); b = q.top(); q.pop(); temp = a + b; ans += temp; q.push(temp); } cout &lt;&lt; ans &lt;&lt; endl; } return 0; }</content></entry><entry><title>二叉树从0到1</title><url>https://yinanhong.site/post/binarytree/</url><categories><category>算法</category><category>数据结构</category></categories><tags><tag>二叉树</tag><tag>算法</tag></tags><content type="html"> 本文介绍关于二叉树的一些基本概念，典型操作，和我做过的比较入门的算法题。所以本文比较适合初学算法的同学，或者用来快速复习什么的。如果是对二叉树的算法比较熟悉的同学，建议可以直接去刷相关的算法题。
二叉树概念 二叉树就是每个节点最多有两个子节点的树。每个节点的内存大小包括【要存储的数据】、【指向子节点的两个指针】。
需要了解的几个概念，图中Tree 1就是一般的二叉树，Tree 2是完全二叉树，Tree 3是满二叉树。完全二叉树除最下面一层，其余层的节点个数必须达到最大，最底层节点全部靠左排列。满二叉树则是所有层的结点个数都需达到最大，显然满二叉树都是完全二叉树。
像上图的数据结构中，发现6、8、9号位置都没有存到数据，会有空间的浪费。而用完全二叉树存储就可以避免这样的问题。实际上所有的树结构都是可以转化成完全二叉树的。
二叉树的遍历操作 遍历就是逐个访问所有节点，而根据访问根节点和左右子节点顺序的不同，二叉树的遍历分为前序、中序、后序遍历。如果把一个运算式的字符串存入二叉树，按照中序输出得到"1+2*3-4"这样的中缀表达式，那按照前序输出就会得到它的波兰式，按后序输出就会得到它的逆波兰式。
前序遍历 前序遍历就是先访问根节点，再访问左子节点，再访问右子节点。上图的输出结果为ABDEGHCF。一些简单的算法题会给出前序遍历的数据，需要通过前序遍历的数据建立二叉树，然后进行其他二叉树的访问操作。
前序遍历的代码（递归实现）很简单：
1 2 3 4 5 6 7 void pre_order(Node* n) { if (n != NULL) { cout &lt;&lt; n->data &lt;&lt; ' '; //访问本节点数据 pre_order(n->left); pre_order(n->right); } } 中序遍历 中序遍历是先访问左子节点，再访问根节点，再访问右子节点。按上面同一棵树的输出结果应为DBGEHACF，图我就不画了太麻烦了&hellip;代码的区别其实就是换一下顺序。
1 2 3 4 5 6 7 void in_order(Node* n) { if (n != NULL) { pre_order(n->left); cout &lt;&lt; n->data &lt;&lt; ' '; //访问本节点数据 pre_order(n->right); } } 后序遍历 后序遍历是先访问左右节点，最后访问根节点。上面那棵树的后序输出为DGHEBFCA。
1 2 3 4 5 6 7 void in_order(Node* n) { if (n != NULL) { pre_order(n->left); pre_order(n->right); cout &lt;&lt; n->data &lt;&lt; ' '; //访问本节点数据 } } 逐层遍历 逐层遍历的意思是从左到右访问每一层的每一个节点。还是上面那棵树，逐层输出就是ABCDEFGH。逐层输出要用到队列，每一层的节点会先被放入队列，访问每一个节点时，将子节点放入队尾。每次循环取出队首的节点，就能实现从上到下，从左到右访问所有节点。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;queue>void BinaryTree::level_order() { if (root == NULL) return; queue&lt;Node*> q; q.push(root); while (!q.empty()) { Node* n; n = q.front(); //取出队首的节点 q.pop(); cout &lt;&lt; n->data &lt;&lt; ' '; //访问节点数据 if (n->left != NULL) q.push(n->left); //将当前节点的左右子节点放入队列 if (n->right != NULL) q.push(n->right); } } 我写的一个二叉树模板类 因为想着这样不用改很多代码就可以实现存不同数据类型二叉树，所以就无聊写了个模板。这个类实现了二叉树中后序遍历，层序遍历，计算高度这些常用操作。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 #include &lt;iostream>#include &lt;string>#include &lt;queue>using namespace std; template &lt;typename T> class Node { public: T data; Node* left; //左子节点 Node* right; //右子节点 }; template &lt;typename T> class BinaryTree { private: Node&lt;T>* root; //根节点 int height; //高度 Node&lt;T>* create_tree(const T* s, int&amp; pos, int s_len); void pre_order(Node&lt;T>* n); void in_order(Node&lt;T>* n); void post_order(Node&lt;T>* n); void level_order(Node&lt;T>* n); void get_height(Node&lt;T>* n, int h); //计算高度 public: BinaryTree(); void create_tree(const T* s, int s_len); void pre_order(); //前序遍历 void in_order(); //中序遍历 void post_order(); //后序遍历 void level_order(); //层序遍历 int get_height(); //获取高度 void ancestor(char A, char B); //todo求两个节点的最大公共祖先 }; template &lt;typename T> BinaryTree&lt;T>::BinaryTree() { root = NULL; height = -1; } template &lt;typename T> Node&lt;T>* BinaryTree&lt;T>::create_tree(const T* s, int&amp; pos, int s_len) { ++pos; Node&lt;T>* n; if (pos >= s_len) return NULL; else { if (s[pos] == '#') //该位置没有节点 n = NULL; else { n = new Node&lt;T>; n->data = s[pos]; n->left = create_tree(s, pos, s_len); n->right = create_tree(s, pos, s_len); } return n; } } template &lt;typename T> void BinaryTree&lt;T>::create_tree(const T* s, int s_len) { int pos = -1; } template &lt;typename T> void BinaryTree&lt;T>::pre_order() { //在公有接口中访问数据，保证私有数据的封装 pre_order(root); cout &lt;&lt; endl; } template &lt;typename T> void BinaryTree&lt;T>::pre_order(Node&lt;T>* n) { if (n != NULL) { //do sth cout &lt;&lt; n->data &lt;&lt; ' '; pre_order(n->left); pre_order(n->right); } } template &lt;typename T> void BinaryTree&lt;T>::in_order() { in_order(root); cout &lt;&lt; endl; } template &lt;typename T> void BinaryTree&lt;T>::in_order(Node&lt;T>* n) { if (n != NULL) { in_order(n->left); //do sth cout &lt;&lt; n->data &lt;&lt; ' '; in_order(n->right); } } template &lt;typename T> void BinaryTree&lt;T>::post_order() { post_order(root); cout &lt;&lt; endl; } template &lt;typename T> void BinaryTree&lt;T>::post_order(Node&lt;T>* n) { if (n != NULL) { post_order(n->left); post_order(n->right); //do sth cout &lt;&lt; n->data &lt;&lt; ' '; } } //用队列进行层序遍历 template &lt;typename T> void BinaryTree&lt;T>::level_order() { if (root == NULL) return; queue&lt;Node&lt;T>*>q; q.push(root); while (!q.empty()) { Node&lt;T>* n; n = q.front(); q.pop(); //do sth cout &lt;&lt; n->data &lt;&lt; ' '; if (n->left != NULL) q.push(n->left); if (n->right != NULL) q.push(n->right); } //do sth cout &lt;&lt; endl; } template &lt;typename T> int BinaryTree&lt;T>::get_height() { if (height == -1) get_height(root, 0); return height; } template &lt;typename T> void BinaryTree&lt;T>::get_height(Node&lt;T>* n, int h) { if (n != NULL) { ++h; if (h > height) height = h; get_height(n->left, h); get_height(n->right, h); } } int main() { //数据类型为char，#表示此处没有节点 string s; s = "ABD##E#F##C##"; BinaryTree&lt;char> a; //数据类型为int，0表示没有 //int s[] = { 1,2,3,0,0,4,0,5,0,0,6,0,0 }; //BinaryTree&lt;int> a; a.create_tree(s.c_str(), s.size()); //a.create_tree(s, 13); cout &lt;&lt; "前序遍历：" &lt;&lt; endl; a.pre_order(); cout &lt;&lt; "中序遍历：" &lt;&lt; endl; a.in_order(); cout &lt;&lt; "后序遍历：" &lt;&lt; endl; a.post_order(); cout &lt;&lt; "层序遍历：" &lt;&lt; endl; a.level_order(); cout &lt;&lt; "树高：" &lt;&lt; endl; cout &lt;&lt; a.get_height() &lt;&lt; endl; return 0; } 一些比较常规的算法题 大部分是学校数据结构课做的。挑一些比较有意思的放出来，会尽量注释详细。
二叉树结点的最大距离 题目描述 二叉树两个结点的距离是一个结点经过双亲结点，祖先结点等中间结点到达另一个结点经过的分支数。二叉树结点的最大距离是所有结点间距离的最大值。例如，下图所示二叉树结点最大距离是3，C和D的距离。 二叉树用先序遍历顺序创建，#表示空树。计算二叉树结点最大距离和最大距离的两个结点(假设二叉树中取最大距离的两个结点唯一）。
输入 测试次数T 第2行之后的T行，每行为一棵二叉树先序遍历结果（#表示空树）
输出 对每棵二叉树，输出树的结点最大距离和最大距离的结点，输出格式见样例。
样例输入 3 A## ABC##EF#G###D## ABEH###F#K### 样例输出 0: 5:G D 4:H K 题目解析 对每个节点，子树的最长路径有两种可能，一种是从根节点到叶子结点（左），一种是从叶子结点到另一个叶子节点（右），而leaf to leaf最大距离 = 根to左侧最深 + 根to右侧最深。所以只用递归采用后序遍历，对每个节点计算最长的根叶子距离和叶子到叶子距离，取较大的那个作为max distance返回。这样到根节点时，就能得到最大的节点路径。
AC代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 #include &lt;iostream>#include &lt;string.h>#include &lt;queue>using namespace std; template &lt;typename T> class Node { public: T data; Node* left; //左子节点 Node* right; //右子节点 }; template &lt;typename T> class BinaryTree { private: Node&lt;T>* root; //根节点 Node&lt;T>* create_tree(const T* s, int&amp; pos, int s_len); int post_order(Node&lt;T>* n, int* record); public: BinaryTree(); void create_tree(const T* s, int s_len); void post_order(); //后序遍历 void max_distance(); }; template &lt;typename T> BinaryTree&lt;T>::BinaryTree() { root = NULL; height = -1; leaves = 0; } template &lt;typename T> Node&lt;T>* BinaryTree&lt;T>::create_tree(const T* s, int&amp; pos, int s_len) { ++pos; Node&lt;T>* n; if (pos >= s_len) return NULL; else { if (s[pos] == '#') //该位置没有节点 n = NULL; else { n = new Node&lt;T>; n->data = s[pos]; n->left = create_tree(s, pos, s_len); n->right = create_tree(s, pos, s_len); } return n; } } template &lt;typename T> void BinaryTree&lt;T>::create_tree(const T* s, int s_len) { int pos = -1; root = create_tree(s, pos, s_len); } template &lt;typename T> void BinaryTree&lt;T>::pre_order() { pre_order(root); cout &lt;&lt; leaves &lt;&lt; endl; } template &lt;typename T> void BinaryTree&lt;T>::max_distance() { int* record = new int; int num = post_order(root, record); if (num) cout &lt;&lt; num &lt;&lt; ":" &lt;&lt; root->l_deepest &lt;&lt; " " &lt;&lt; root->r_deepest &lt;&lt; endl; else cout &lt;&lt; 0 &lt;&lt; ":" &lt;&lt; endl; delete record; } //最大距离可能为 //1.node左子树上最大距离 //2.node右字数上最大距离 //3.node左子树深度+右子树深度 template &lt;typename T> int BinaryTree&lt;T>::post_order(Node&lt;T>* n, int* record) { if (n == NULL) { *record = 0; //存深度 return 0; } int l_max = post_order(n->left, record); //左子树上最大距离 int l_depth = *record; //左子树深度 int r_max = post_order(n->right, record); //右子树上最大距离 int r_depth = *record; //右子树深度 int cur_node_depth = l_depth + r_depth; //左子树深度+右子树深度 *record = max&lt;int>(l_depth, r_depth) + 1; //当前节点深度 return max&lt;int>(max&lt;int>(l_max, r_max), cur_node_depth); //返回当前节点的最大距离 } //也就是当前节点作为根节点，其子节点的最大距离 int main() { int t; cin >> t; while (t--) { char* s = new char[100]; cin >> s; BinaryTree&lt;char> bt; bt.create_tree(s, strlen(s)); bt.max_distance(); delete[] s; } return 0; } 求根到叶子结点路径上权值的和 题目描述 给定一棵二叉树的逻辑结构（先序遍历的结果，空树用字符‘0’表示，例如AB0C00D00），建立该二叉树的二叉链式存储结构 二叉树的每个结点都有一个权值，从根结点到每个叶子结点将形成一条路径，每条路径的权值等于路径上所有结点的权值和。编程求出二叉树的最大路径权值。如下图所示，共有4个叶子即有4条路径
路径1权值=5 + 4 + 11 + 7 = 27 路径2权值=5 + 4 + 11 + 2 = 22 路径3权值=5 + 8 + 13 = 26 路径4权值=5 + 8 + 4 + 1 = 18 可计算出最大路径权值是27
该树输入的先序遍历结果为ABCD00E000FG00H0I00，各结点权值为： A-5，B-4，C-11，D-7，E-2，F-8，G-13，H-4，I-1
输入 第一行输入一个整数t，表示有t个测试数据 第二行输入一棵二叉树的先序遍历，每个结点用字母表示 第三行先输入n表示二叉树的结点数量，然后输入每个结点的权值，权值顺序与前面结点输入顺序对应 以此类推输入下一棵二叉树
输出 每行输出每棵二叉树的最大路径权值，如果最大路径权值有重复，只输出1个
样例输入 2 AB0C00D00 4 5 3 2 6 ABCD00E000FG00H0I00 9 5 4 11 7 2 8 13 4 1 样例输出 11 27 题目解析 先序建树，然后后序遍历节点，记录访问过的节点的数据，访问根节点时比较取权值较大的子树。比如图中7>2，访问11时就取7。递归到最后得到的就是权值最大的数据。
其实可以优化，边建树边计算数据，效率会更高，但是做的时候没想到，就不写了。
AC代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 #include &lt;iostream>using namespace std; int cnt; int* dt; template &lt;typename T> class Node { public: T data; Node* left; //左子节点 Node* right; //右子节点 }; template &lt;typename T> class BinaryTree { private: Node&lt;T>* root; //根节点 int height; //高度 Node&lt;T>* create_tree(const char* s, int&amp; pos, int s_len); int post_order(Node&lt;T>* n); public: BinaryTree(); void create_tree(const char* s, int s_len); void post_order(); //后序遍历 }; template &lt;typename T> BinaryTree&lt;T>::BinaryTree() { root = NULL; height = -1; } template &lt;typename T> Node&lt;T>* BinaryTree&lt;T>::create_tree(const char* s, int&amp; pos, int s_len) { ++pos; Node&lt;T>* n; if (pos >= s_len) return NULL; else { if (s[pos] == '0') //该位置没有节点 n = NULL; else { n = new Node&lt;T>; n->data = dt[cnt]; cnt++; n->left = create_tree(s, pos, s_len); n->right = create_tree(s, pos, s_len); } return n; } } template &lt;typename T> void BinaryTree&lt;T>::create_tree(const char* s, int s_len) { int pos = -1; root = create_tree(s, pos, s_len); } template &lt;typename T> void BinaryTree&lt;T>::post_order() { cout &lt;&lt; post_order(root) &lt;&lt; endl; } template &lt;typename T> int BinaryTree&lt;T>::post_order(Node&lt;T>* n) { if (n == NULL) return 0; int max1, max2; max1 = post_order(n->left); max2 = post_order(n->right); return max1 > max2 ? max1 + n->data : max2 + n->data; //返回权值较大的子树 } int main() { int t; cin >> t; while (t--) { string s; cin >> s; //s存的节点名称 int num; cin >> num; dt = new int[num]; for (int i = 0; i &lt; num; i++) cin >> dt[i]; //存节点的数据 BinaryTree &lt;int> btree; btree.create_tree(s.c_str(), s.size()); btree.post_order(); delete[] dt; } return 0; } 后序遍历的非递归算法 因为递归的实现是通过栈，递归到下一层的时候，把当前的函数压栈。所以如果有一棵树特别长，就会发生栈溢出。所有的递归，都是可以通过非递归的方式实现的，这就是这道算法题的背景知识&hellip;
输入 第一行输入一个整数t，表示有t个测试数据 第二行起输入二叉树先序遍历的结果，空树用字符‘0’表示，输入t行
输出 逐行输出每个二叉树的后序遍历结果
样例输入 3 AB0C00D00 ABC00D00EF000 ABCD0000E0F00 样例输出 CBDA CDBFEA DCBFEA 直接上代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 #include &lt;iostream>#include &lt;string>#include &lt;stack>using namespace std; template &lt;typename T> class Node { public: T data; Node* left; //左子节点 Node* right; //右子节点 }; template &lt;typename T> class BinaryTree { private: Node&lt;T>* root; //根节点 Node&lt;T>* create_tree(const T* s, int&amp; pos, int s_len); void post_order(Node&lt;T>* n); public: BinaryTree(); void create_tree(const T* s, int s_len); void post_order(); //后序遍历 }; template &lt;typename T> BinaryTree&lt;T>::BinaryTree() { root = NULL; } template &lt;typename T> Node&lt;T>* BinaryTree&lt;T>::create_tree(const T* s, int&amp; pos, int s_len) { ++pos; Node&lt;T>* n; if (pos >= s_len) return NULL; else { if (s[pos] == '0') //该位置没有节点 n = NULL; else { n = new Node&lt;T>; n->data = s[pos]; n->left = create_tree(s, pos, s_len); n->right = create_tree(s, pos, s_len); } return n; } } template &lt;typename T> void BinaryTree&lt;T>::create_tree(const T* s, int s_len) { int pos = -1; root = create_tree(s, pos, s_len); } template &lt;typename T> void BinaryTree&lt;T>::post_order() { post_order(root); cout &lt;&lt; endl; } template &lt;typename T> void BinaryTree&lt;T>::post_order(Node&lt;T>* n) { Node&lt;T>* p; stack&lt;Node&lt;T>*> s1; stack&lt;int> s2; int tag; p = n; do { if (p != NULL) { tag = 0; s1.push(p); s2.push(tag); p = p->left; } if (s1.empty()) break; if (p == NULL) { tag = s2.top(); if (tag == 0) { s2.pop(); s2.push(1); p = s1.top()->right; } if (tag == 1) { p = s1.top(); cout &lt;&lt; p->data; s1.pop(); s2.pop(); p = NULL; } } } while (!s1.empty()); } int main() { int t; cin >> t; while (t--) { string s; cin >> s; BinaryTree&lt;char> a; a.create_tree(s.c_str(), s.size()); a.post_order(); } return 0; } 用中后序输出的数据建树 题目描述 按中序遍历和后序遍历给出一棵二叉树，求这棵二叉树中叶子节点权值的最小值。 输入保证叶子节点的权值各不相同。
输入 第一行输入一个整数t，表示有t组测试数据。 对于每组测试数据，首先输入一个整数N (1 &lt;= N &lt;= 10000)，代表二叉树有N个节点，接下来的一行输入这棵二叉树中序遍历的结果，最后一行输入这棵二叉树后序遍历的结果。
输出 对于每组测试数据，输出一个整数，代表二叉树中叶子节点权值最小值。
样例输入 3 7 3 2 1 4 5 7 6 3 1 2 5 6 7 4 8 7 8 11 3 5 16 12 18 8 3 11 7 16 18 12 5 1 255 255 样例输出 1 3 255 题目解析 因为后续输出的最后一个一定是根节点，就可以通过后序的数据在中序的数据中找到根节点，然后中序的数据中，根节点左边一定是左子树，右边一定是右子树。中序是先输出左子树，后序也是先输出左子树，找到后序的左子树部分的最后一个节点，就是左子树的根节点。详细的看代码。
AC代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 #include &lt;iostream>using namespace std; class Node { public: int data; Node* left, * right; }; class BiTree { private: Node* root; int num; // num of nodes int* post; int* in; int min; Node* CreateTree(int* post, int* in, int n); void preorder(Node* p); void getMin(Node* p); public: BiTree(); ~BiTree(); void CreateTree(); void preorder(); int getMin(); }; BiTree::BiTree() { cin >> num; post = new int[num]; in = new int[num]; for (int i = 0; i &lt; num; i++) cin >> in[i]; for (int i = 0; i &lt; num; i++) cin >> post[i]; root = CreateTree(in, post, num - 1); } BiTree::~BiTree() { //理论上是要删节点的 delete[] post; delete[] in; } Node* BiTree::CreateTree(int* in, int* post, int n) { //n是新建节点在post的位置 if (n == -1) return nullptr; int i = 0; for (; in[i] != post[n]; i++); //用i记录在in串的位置 Node* node = new Node; node->data = post[n]; node->left = CreateTree(in, post, i - 1); //in指针起始位置移当前结点的下一个，剩下的串为右子树节点 //post指针【起始位置】移到后移i位，i为左子树的结点数，剩下的串为右子树节点 //post[n-i-1]是下一个递归的post[n] node->right = CreateTree(in + i + 1, post + i, n - i - 1); return node; } void BiTree::getMin(Node* p) { if (p->left == nullptr &amp;&amp; p->right == nullptr) { if (p->data &lt; min) min = p->data; return; } if (p->left != nullptr) getMin(p->left); if (p->right != nullptr) getMin(p->right); } int BiTree::getMin() { //其实也是在建树的时候就可以计算数据，时间会少一半左右 //但是建树的代码比较复杂，所以就不让它更复杂了吧 //这个就是简单的前序遍历找权值最小的叶子结点 min = root->data; getMin(root); return min; } int main() { int t; cin >> t; while (t--) { BiTree mytree; cout &lt;&lt; mytree.getMin() &lt;&lt; endl; } } 二叉树的中后序遍历及操作 题目描述 按中序遍历和后序遍历给出一棵二叉树，现在有如下操作：
UPDATE A B，将中序遍历中A位置（从1开始编号的下标）对应的在二叉树中的节点的权值改为B QUERY，询问树上所有节点的权值，以及从根节点到该节点的路径权值之和 STOP，停止操作，STOP操作一定出现在最后 中序遍历和后序遍历的输入保证叶子节点的权值各不相同。但是，之后如果存在UPDATE操作，则UPDATE操作可能会使得两个或两个以上的叶子节点的权值相同。 输入 输入t组测试数据； 接下来输入k组测试数据，对于每组测试数据： 第一行输入这棵二叉树的结点数 第二行输入这棵二叉树中序遍历的结果
第三行输入这棵二叉树后序遍历的结果 接下来每一行输入一种操作，直到输入STOP操作时结束本组测试数据的输入。其中，QUERY操作次数 &lt;= 2，总操作数 &lt;= 104
输出 对于每组测试数据： 对于QUERY操作，按中序遍历输出节点的权值，以及从根节点到该节点路径权值之和。这里，我们认为根节点到其本身的路径权值之和为根节点的权值
题目解析 因为update操作可能会导致权值相同，所以用权值查找节点可能找的不准，要用序号找，注意到这一点就应该没啥问题了。然后每查询一次就遍历一次其实效率会比较低，可以用一个指针数组，存序号对应的节点，然后update的时候从数组访问节点。那这么一看好像连建树都不用了&hellip;不过我做的时候没想到，用的update一次就遍历一次的方法QwQ
样例输入 3 7 3 2 1 4 5 7 6 3 1 2 5 6 7 4 UPDATE 5 99 UPDATE 6 123 UPDATE 1 37 QUERY UPDATE 1 36 QUERY STOP 8 7 8 11 3 5 16 12 18 8 3 11 7 16 18 12 5 QUERY STOP 1 255 255 STOP 样例输出 37 43 2 6 1 7 4 4 99 226 123 127 6 133 36 42 2 6 1 7 4 4 99 226 123 127 6 133 7 12 8 31 11 23 3 26 5 5 16 33 12 17 18 35 AC代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 #include &lt;iostream>using namespace std; class Node { public: int data; Node* left, * right; }; class BiTree { private: Node* root; int num; // num of nodes int* post; int* in; int a; int b; Node* CreateTree(int* post, int* in, int n); void inOrder(Node* n, int&amp; cnt); void query(Node* n, int cnt); public: BiTree(); ~BiTree(); void update(); void query(); }; BiTree::BiTree() { cin >> num; post = new int[num]; in = new int[num]; for (int i = 0; i &lt; num; i++) cin >> in[i]; for (int i = 0; i &lt; num; i++) cin >> post[i]; root = CreateTree(in, post, num - 1); } BiTree::~BiTree() { delete[] post; delete[] in; } Node* BiTree::CreateTree(int* in, int* post, int n) { if (n == -1) return nullptr; int i = 0; for (; in[i] != post[n]; i++); Node* node = new Node; node->data = post[n]; node->left = CreateTree(in, post, i - 1); node->right = CreateTree(in + i + 1, post + i, n - i - 1); return node; } void BiTree::update() { cin >> a >> b; int cnt = 0; inOrder(root, cnt); } void BiTree::inOrder(Node* n, int&amp; cnt) { if (n == nullptr) return; inOrder(n->left, cnt); cnt++; if (cnt == a) n->data = b; else inOrder(n->right, cnt); return; } void BiTree::query() { query(root, 0); } void BiTree::query(Node* n, int cnt) { if (n == nullptr) return; cnt += n->data; query(n->left, cnt); cout &lt;&lt; n->data &lt;&lt; ' ' &lt;&lt; cnt &lt;&lt; endl; query(n->right, cnt); return; } int main() { int t; cin >> t; while (t--) { BiTree mytree; string cmd; while (cin >> cmd) { if (cmd[0] == 'U') mytree.update(); if (cmd[0] == 'Q') mytree.query(); if (cmd[0] == 'S') break; } cout &lt;&lt; endl; } } Falling Leaves （DFS求每一列权值的和） 题目描述 按先序遍历给出一棵二叉树，每个结点都有一个水平位置：左子结点在它左边一个单位，右子结点在右边1个单位。从左向右输出每个水平位置的所有节点的权值之和。 例如：以下二叉树有三个水平位置，从左至右的输出是7,11,3。
输入 测试数据有多组，每组测试数据输入按先序遍历输入一棵二叉树，其中-1代表空节点（一棵树的节点数量不超过 103） 当输入的二叉树是一棵空树时，结束输入。
输出 对于每组测试数据，首先输出一行"Case x:"，其中x代表这是第x个测试数据的输出，然后从左到右输出每个水平位置所有节点的权值之和
样例输入 5 7 -1 6 -1 -1 3 -1 -1 8 2 9 -1 -1 6 5 -1 -1 12 -1 -1 3 7 -1 -1 -1 -1 样例输出 Case 1: 7 11 3 Case 2: 9 7 21 15 题目解析 这个题目说的不是人话。用人话说是，输出每一竖列节点的权值和。其实这道题不用建树，大概判断一下最多可能有多少列，然后开个数组存每一竖列的权值和。因为先序的数据是根、左、右，所以只用写个巧妙的递归就能计算出结果。
AC代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include &lt;iostream>#include &lt;string.h>using namespace std; const int maxn = 200; int sum[maxn]; void build(int p) { int v; cin >> v; if (v == -1) return; //空树返回 sum[p] += v; build(p - 1); build(p + 1); } bool init() { int v; cin >> v; if (v == -1) return false; memset(sum, 0, sizeof(sum)); int pos = maxn / 2; //根节点位置 sum[pos] = v; build(pos - 1); //左子树 build(pos + 1); //右子树 } int main() { int _case = 0; while (init()) { int p = 0; while (sum[p] == 0) p++; cout &lt;&lt; "Case " &lt;&lt; ++_case &lt;&lt; ":\n" &lt;&lt; sum[p++]; while (sum[p] != 0) cout &lt;&lt; ' ' &lt;&lt; sum[p++]; cout &lt;&lt; "\n\n"; } return 0; }</content></entry><entry><title>该关注的不止是处长体验外卖员生活</title><url>https://yinanhong.site/post/workersday/</url><categories><category>键政</category></categories><tags><tag>劳资矛盾</tag><tag>996</tag><tag>社会问题</tag></tags><content type="html"> 五一国际劳动节  国际劳动节又称“五一国际劳动节”、“国际示威游行日”（International Workers' Day或者May Day），是世界上80多个国家的全国性节日。定在每年的五月一日。它是全世界劳动人民共同拥有的节日。
 19世纪，随着第二次工业革命，资本主义发展到帝国主义阶段，为了刺激经济高速发展，压榨更多的剩余价值，资本家采取增加劳动时间和劳动强度的方法，来剥削工人。在美国，工人每天要劳动14至16小时，有的甚至长达18小时，但工资却很低。
 1886年5月1日，以美国芝加哥为中心，举行了约35万人的大规模罢工和示威游行，争取八小时工作制。
讲个网约车行业的故事  最近打滴滴，遇到的司机都喜欢聊政治，我晕车不敢玩手机，就只能唯唯诺诺跟司机侃大山…
 昨晚遇到的司机师傅，是因为做生意不成功，只好关掉自己的仓库，从事网约车行业。不难想象，在2020年疫情的冲击下，很多失业人员会选择从事网约车、外卖员、快递员之类的行业。这些行业的共同特点是，不需要有什么专业知识储备，不需要有经验，基本是靠体力劳动多劳多得。
平台没有给司机足够的保障  我在高一还是高二的时候，为了完成社会实践课的作业，还做过一次出租车行业的调查，对网约车行业有些许了解，于是问了司机师傅一些我关注的问题。网约车平台限制司机每天的载客时间（空载时间不算），大概是不能超过十小时。人和车绑定，所以不能像出租车那样两个人轮班倒。如果司机一个月30天都不休息，每天勤快点跑十多个小时，那一个月的收入可以有10k以上。不过司机师傅感觉最近接到的单越来越少，可能是因为有太多人来从事这个行业，人多了分到的单就少了。这种情况在外卖员之类的类似的行业也可能会有。
 司机师傅还讲了个有意思的事情。他载过一些十八九岁的年轻乘客，都是去一些工厂打工的，这些乘客在快下车前总是会（假装）打电话或者聊微信，下车时就会说打完电话之后再付款，然而这些人之后一般都不会付款，这部分损失是由司机自己承担的。我问，遇到这样的行为，平台会做什么吗？得到的答案令我很无语。平台在一天内会以短信的形式提醒乘客付款，如果乘客还是没有付款的话，平台会给司机一个虚拟手机号，司机自行联系乘客。但如果乘客还是没付款的话，三五天后那个虚拟手机号就失效了，司机也只能自己承担损失了。
网约车体系，某滴涉及所有类型，其他公司则专注细分领域
 我自己用过的一些平台，比如某团啊，是要在上车前先付款，然后到了目的地之后多退少补的，这样对大家都有保障。于是我接着问了，有没有什么行业工会啊，或者有没有什么保护自身权利的方法啊之类的。答案自然是都没有的。
北京人社局处长体验外卖员职业  前几天这个视频还是比较火的，相信不少人都看过。大致内容是北京人社局一个副处长，为了制定更符合新业态工作人员（外卖员、网约车司机等）需求的政策，亲自注册了一个美团账号，跟着一个真的外卖员送了一天外卖。里面有几个值得注意的点啊。
 首先这个纪录片不是那种主旋律的，一定程度上真实地反映了外卖员的工作和生活。
 副处长送了几单之后，累的不行，提出需不需要平台提供一个送几单就休息一下的机制。外卖小哥却说不希望限制最高或最低工作时长。
 后来副处长问了小哥的梦想，小哥回答说想成立一个骑手之家。虽然我觉得这有一定的剧本嫌疑，不过我在网上看到有些评论说这是想要一个类似工会的组织。
 视频里还提到，平台其实和骑手之间存在一定的管理关系，而视频后面又说了骑手如果意外受伤后没有医疗保障的问题。
 本来是想讲讲工会的，但是怕篇幅太长了没人看，有机会单独写一篇文章吧。
 底层劳动人民缺少维护自身利益的意识，这就让资本有了剥削无产阶级的机会。而实际上工会，特别是中国的工会并没有很大的存在感，也没有很好地起到了维护工人利益的作用。你看码农工会可不就在那里，然而码农该996的996，该251的251。所以最重要的是，无产阶级需要有维护自身利益的意识，要有团结起来维护阶级利益的意识。
每个行业都有劳资矛盾  其实所有行业，不只是外卖员和网约车司机，劳动者想要获得更高的劳动报酬，其实只能通过增加劳动时间和劳动强度的方式。996其实也是同样的道理。现状就是，老板提供了资本，工人提供了劳动力，老板想要用更少的代价换来更多的收益（剩余价值），工人只能通过增加劳动时间和劳动强度来获得更高的报酬。如果通过监管，限制劳动的话，其实牺牲的是两方的利益，因为就是有人愿意用高强度、长时间工作来换取更高的报酬。
 像网约车行业这样，疲劳驾驶有可能危害乘客的生命安全，所以有必要存在限制劳动的制度。而外卖员没有限制劳动的制度，外卖员意外受伤却没有任何的保障，外卖员不但要承担自己的医疗，还损失了工作时间。又因为上一段提到的，监管其实不应该限制劳动。其他行业同理，比如程序员，996能赚钱，但是过劳死的风险和代价需要自己承担。
互联网公司没有明文要求996,但到了下午六七点根本没人走，领导也十点多才走，你敢早走吗？
劳资矛盾的现象规律  当劳动者多了之后，劳动力的价值就降低。当人口红利过去，劳动力价值提高之后，资本家不愿意给你更多的工资怎么办呢？这时候就出现了内卷、奋斗者协议之类的东西。内卷说白了就是韭菜在恶性竞争，资本家正好趁机压低韭菜价格，至于奋斗者协议那就是个傻韭菜才会签的东西。 政策方面，比如五一调休这波骚操作，其实也是各方矛盾综合下的结果。五天假期减去调休的两天就还剩三天，三天减去原本两天的周末，调来调去实际上只放了一天。假期延长提高了出行欲望，带来了更多的经济效益，同时又没有损失调休两天的社会生产。总之，劳动者，资本和政府之间存在着诸多矛盾，相互制约之下形成了现在的社会经济体系。
无产阶级应该抗争  资本家出钱，劳动者出力，赚的钱是资本家分到了大多数，这样显然不是实现共同富裕的方式。但提高税收，提高最低工资标准，禁止高强度工作这样的制度也不是拍拍脑袋说行就行的。
 北欧的高社会福利国家（真正的社会主义国家狗头）能通过对有钱人高额征税来实现高社会福利，这是基于人少和产业结构优。随着我国人口自然增长率的下降，劳动力价值的提升我觉得是自然而然的事情，内卷只是一时的。想要人人都过的好，还是要靠更优的产业结构和更优的分配制度。喊着“劳动人民最光荣这样的口号”来骗取劳动力的日子已经过去，无产阶级同志们想要过上好日子，需要团结起来，为自己阶级的利益抗争。
 最后祝所有劳动人民劳动节快乐。
 </content></entry><entry><title>我就是太理想主义了</title><url>https://yinanhong.site/post/idealism/</url><categories><category>生活杂谈</category></categories><tags><tag>生活杂谈</tag></tags><content type="html"> 题外话  好久没更新了，因为我懒，或者我忙。其实这段时间有挺多话说的，大概从过年那段时间开始，关于人人影视被封和国内的盗版文化，后来两会期间的各种迷惑议题，教育部明文禁手机和深中的反应，再到最近的棉花。热度都过了不写了…
 为了今年的flag不倒，我还是勉为其难更新一下公众号，虽然我的电钢琴已经沦为吉他谱架了&hellip;
我就是太理想主义了  我总是期望事情往好的方向发展，虽然我会为最坏的情况做准备，但还是会期待最好的情况的出现。比如做官微采访的时候，总是会期待能有很好的素材，但我也会为交上来的素材全都不能用的情况做准备。比如不去上课的时候会期待不点名，但我也做好了被扣考勤分的准备…
 虽然事情总是会turn out as bad as it can be&hellip;
 我希望我和朋友的关系是非常理想化的，但身边的人恕我直言都太现实了，感觉没有人能get到我很理想主义的点，所以感觉在现在呆的地方没有什么关系很好的朋友。反正我这辈子就是在不断地getting out of a shitty place and getting in another, 已经在期待下一个shit hole了。
最近心情不错  我终于能说我放下了一些去年发生的不好的事，然后正在尝试放下更多更早发生的不好的事。
 （quote孙燕姿）我不难过，这不算什么，开始懂了，快乐是选择&hellip;两三年来，能让我快乐的事只有睡觉，终于现在吃东西和看剧又能让我感到快乐了……
关于学习  虽然说学校不知道说了多少以就业为导向，但怎么都不是以offer为导向教学。毕竟不是每个高中都有生涯教育之类的，感觉身边还是有很多人不知道该干嘛的。我还是管好自己，以offer为导向自学吧…
 但是不得不吐槽，java基础语法能讲三四个星期，数据结构讲顺序表、链表讲了三四个星期&hellip;上学期的操作系统跟没讲操作系统一样，下学期要怎么边学计网边找实习？逗我8&hellip;拿一学期出去实习作为必修课程真的有必要吗？
 顺便，上学期末告诉我上机题目课上做完给满分，课下做完只给一半分我实在无语，虽然我做完的也不少。有些朋友，出于任何目的，为了装逼也好，真就为了成绩也好，课前找别的班的要题目，然后在课上敲完的，恕我直言都是垃圾。期末考了a+还有脸晒出来的我真是佩服的五体投地&hellip;这年头脸皮比我厚的人不多了。
 Anyway，现在学的东西谈不上喜欢…要不是为了当码农工资高大概率不会来…
关于人际  周围的各位大哥最近都在忙赛车工作室忙的要死，没人陪我玩。我还是很不想social扩充交际圈什么的，太累人了。不愿为了social付出时间和精力，总感觉有点亏，不如多睡一会。
 感觉我之前立的人设让大家多多少少有点误解，给我带来了一些困扰。想澄清一下我不是富二代，住在深圳的人家里不一定有钱 =.= 我虽然还没穷到吃不起饭，但也过不上小资生活。我家里没有任何物质or anything留给我（不是不给是真没有），甚至连个像样的家(mental and physical)都没。我只能靠自己实现阶级跨越，so，leave me alone 别烦我
 前段时间有人跟我说不敢跟我接近，因为怕我对他做出我曾经做过最恶劣的事。Well，首先要是你没对我做出什么恶劣的事，为什么要assume我会对你做什么呢…然后，最近放假二刷复联四，就很希望能有这么个惺惺相惜的朋友之类的whatever
 可能就，太理想主义了。这么美好的关系怎么可能真的存在嘛，要有也不会发生在我身上吧。反正，谁不喜欢我就fuck off吧，越来越觉得just be myself and let其他事顺其自然就好了。最近心态很好，没什么能影响我的好心情…
关于漫威  By the way，寡姐电影又双叒叕改档了QwQ，五一没盼头了，盼暑假吧。还有毒液2啊啊啊啊。感慨一下没有漫威电影的2020，世界赶快好起来QwQ求求了。
 最近看剧没什么讨论社群，于是第一次下了某瓣，结果发现里面就是一堆喷子嘛&hellip;旺达幻视有红女巫的颜撑着，路人评价还不错，到猎鹰冬兵就各种评价水时长水剧情&hellip;我是真的无语。比方说看小说也没有从最后一部开始看，看不懂世界观看不懂梗然后差评的吧&hellip;个人更喜欢猎冬多过幻红，幻红更多的是为后面电影的铺垫，猎冬不仅铺垫还更完善了漫威宇宙世界观，不细说了。
Ending  噢对了，最近感觉有点胖，又开始锻炼了一下两下三下…但是我真的瘫了太久了，真的不会中考那一阵子是我这辈子的体能巅峰了吧不会吧不会吧不会吧&hellip;
 最后祝大家开心，希望世界和平love &amp; peace
 Over
 </content></entry><entry><title>洪逸楠的2020个人年度总结</title><url>https://yinanhong.site/post/2020yearly/</url><categories><category>生活杂谈</category></categories><tags><tag>feelings</tag></tags><content type="html">  2020年唯一的收获就是兔楠又回来了，嗯，就是内个帅气阳光开朗乐观，想在自己的票圈里成为网红的小伙汁。
 这辈子第一次写年度总结，前几天在构思的时候想的都是怎么吐槽我这一年来经历的种种不快，但这样多没意思呀，还是认认真真总结一下这一年的收获、成长、错误和遗憾吧。（写完回来补了句：还是写得很随便，记录了一下心情，心路历程什么的
 从高二开始我的情绪就一直在走下坡路，在高考前后达到最低谷。原因浓缩成两个字——family drama（家庭抓马）。要讲我的家庭和成长经历，两天都讲不完，还记得五月和祥乐在八楼天台从九点十点聊到一两点还意犹未尽。总之，我能回到原来兔楠的状态实属不易。
2020.1.1  这天在军训，深中游园会去不成了，不嗨森。放寒假了，只约了cc、pz出去喝了个酒吃了个烧烤。本想除夕去二姑家陪我奶奶她老人家过个年，呆个一星期就回学校，都想好在假期要怎么弯道超车了。然而这该死的疫情把我困在了二姑家两个月。
 只能说家里人在让我失望这件事情上从未让我失望。临近网课开课，我撂下一句你这辈子再也别想见到我，拉上行李回了大姑家。
2020.3.2  网课第一天，第一节是高数课。虽然大一上学期高数考了A，但是在学期末讲的为下学期开头的内容就没听过，网课啥也没听，然后第一次也是我最后一次出席高数网课。因为下定了决心要转专业，所以像机械原理啊，大物啊这些课我是一点听的兴趣都没有。状态确实不好，每天就是睡大觉。好在有好好学C语言，或许是有天赋（？），现在看来基础还算够用。
 盘点一下疫情期间刷的美剧，911（紧急救援）系列4季，是真的好看，虽然各种美国zz正确，但是真的好看；upload（上载新生），新剧，像是黑镜的哪一集，是讲人快死时把人的意识上传到server继续云生活的，有点意思值得等第二季；homeland（国土安全）八季，已完结神剧，开始追时在播出最后一季，看到最后一季正好全部播完，爽！当之无愧的神剧！这辈子看过最好看的剧情片，是以CIA在围绕中东局势的各种行动之类的展开的剧情，好看的不得了，里面主角死了就是死了，一点光环都没有的那种，这才是真正的爱国主义吧，写在脸上刻在骨子里的爱国。
 Anyways&hellip;.我网课时期就浑浑噩噩地这么过去了。哦对了，开学前和老同学们聚的几次都很开心，想大家了~
 如果重新来过的话，我估计这段时间我还是会打不起精神来，不是我没毅力，是真的累，心累。
2020.5.16  啦啦啦没人送我，前一天收拾好行李，第二天早早起来戴上口罩就去北站→坪山站→学校了。一个以前的朋友出了点事，那时我还会为他担心，他晚了一个星期回学校。到这个时候，我还是整天一副比较颓的状态，想平平淡淡过完四年就好，心态就像高三和Donna说的，我只想一切都稳定下来，虽然听起来很老年，但我真的不想再有什么起伏了。
 虽然大一上学期只是稍微学了下习，但也随随便便考到了专业第二，但大一下是真的没学，那时候身边的人各种虚伪我。我本来就没学就挺慌的，还整天有人在耳边念叨不用学都能考A+辣，真的深中虚伪的ptsd。这次我发了个小脾气，被祥乐拉去八楼谈心，然后这学期的声乐课让我和林生成为了好盆友。也让我发现了，如果我愿意去交朋友，还是有很多人愿意跟我玩的。
 我这么大方的人当然不会为一些小事生很久的气，很快大家又恢复了友善。最后的友善。
 对了，6.1那天老朋友来村探望，开心！
2020.7.9  这天考C语言，这天我生日，收到了大家的礼物，即使第二天考高数，我还是很开心。暑假到了，我不想回姑姑家，因为宿舍有大屏幕很爽…疫情让我半年见不到我的大屏幕呜呜呜。但学校一定要赶人走。临近离校期限，招生办要招勤工俭学的学生，会做推文会ps、pr又有颜值加成可以带学生家长参观校园的我果然被选上了。于是和以前的一个朋友在学校呆了一个暑假，在招生办打了一暑假暑假工。
 除了cc生日那天下午进了趟城，晚上回了学校，下一次进城就要到国庆了。假期借了林生的吉他，于是过着白天去招生办打工，晚上回来练吉他的充实生活。两个月的时间练到能勉勉强强自弹自唱啦！开心！放假前期还骑车去了趟海边，放假后期还去了趟大梅沙游泳，都是跟以前的一个朋友，开心。暑假还开始尝试用ipad画画，买来这板子终于生产力了一下。至少会自己画表情包了。
2020.9.1  如愿顺利转了专业，感觉一切又好了起来。远离家人大半年，知道了一个人有多清净。踏出舒适圈的第一步是决定写公众号，第二步是当了个朋导。朋导就是类似于深中的学长团，小大一刚来学校的时候带带他们。朋导的竞选很仓促啊，前一天发通知，过几天就演讲竞选了，然后再过几天大一就开学了&hellip;好像在新生开学前几天发了本号第一篇推文。
 就简单讲了下高中社团经历，对朋辈的理解，对学长团的理解，于是很顺利地被班主任相中捞去当了朋导。据说我当时还挺抢手的&hellip;傲娇脸
2020.10.1  这学期实在是太忙了，太！忙！了！很显然刚开学，我在忙新生的事我在忙学习的事我还在忙做官微推文，明明我事情最多，谁也别跟我比。被影响了休息，我逐渐暴躁。我有充足的理由发脾气，我确实没有留余地，他们自然做出了不留余地的选择。经历了什么不是当事人是一定不会了解到全部，一定做不到感同身受的。所以谁也别judge谁。就连我觉得最了解这件事的局外人都不能理解我的感受。如果当时大家都忍一时风平浪静，退一步越想越气的话现在可就是另一种剧情了。
 我做的最错的地方大概是发脾气没发在该被发的人身上。虽然道过歉了，但哆啦A梦还是挺无辜的，希望他一切都好。As for 我讨厌的人，如果过的好的话低调一点不要让我知道，如果过得不好的话说给我听让我开心一下。
 以为删光了痕迹就不会再记起了，然而&hellip;想必他们也一样吧
 心态再度爆炸，你信不信我也是会难过的？他们搬走那天晚上我把宿舍收拾得很干净，不想睡觉，即使第二天要考作文比赛和阅读比赛。虽然基本相当于没睡，但第二天随随便便考完还是进了复赛&hellip;于是后面的日子就在每天满课满课满课，周末总是有大大小小的比赛或开会。能休息或安安静静自习的大块时间越来越少，烦人的专业水课越来越多。（说的就是你RFID、传感器，统统去死吧
2020.11.11  因为之前申到了奖学金，加上宿舍略显空旷，于是买来了一个新朋友。心态逐渐平复，该干嘛干嘛。发现帆帆会弹钢琴，技大杰伦唱歌好听，人又帅，多了个好朋友，开心。后面除了天天满课，一堆作业，推文，各种校级小比赛就没啥特别的事情了，还是没有时间睡觉。双十二真·裸考了个四级，一套模拟题都没做过&hellip;考试前一天才知道的做完听力要收第一张答题卡&hellip;anyway考得还行，要不是学校大一不统一考我早过了&hellip;
 吃了顿宿舍火锅，去了趟较场尾团建，十二月就这么过去辣！
总结一下  因为本来就对自己没什么期待，找回了自己也算是意料之外的惊喜吧。感想所有关注我，关心我，支持我的人。遗憾就是没能在我以后要从事的专业领域有什么很大的进展，没能参与什么项目开发或科研项目QwQ但在日常用自己的电脑的时候能稍微像程序员一点地去解决一些小问题了&hellip;
 最近在做一个关于大家2020年flag完成情况的采访推文（是官微的啦），立一下2021的flag吧！
真的找时间开放个小东西吧，小程序也行啊(本站也算吧&hellip;哭了&hellip;)
坚持写公众号啊啊
练琴练吉他（这是这几个里最有可能完成的&hellip;
[] 锻炼身体keep fit
最后
该死的2020
fuck off
2021对我好点！
 </content></entry><entry><title>从深中到深技大的校园民主</title><url>https://yinanhong.site/post/campusdemocracy/</url><categories><category>生活杂谈</category></categories><tags><tag>校园民主</tag></tags><content type="html">  本文有很多超链接，在公众号里阅读体验更好噢~点击左侧sidebar，头像下方的微信公众号，扫码关注，回复校园民主。
 本页面中这样的文本为超链接。
 趁着自己还是学生写一篇校园相关的，就感觉讨论自己身边的事，格局有点小，以后大概不会写很多学校的事…没法做到很客观=.=
深圳中学的民主实践  从高中我就一直在思考的问题，什么才是真正的校园民主，什么样的制度能有效地维护学生的权益？
 深中的民主自由也算是一大校园特色了。在深中还有校园民主这回事，是由于学生有维护自己权利的意识，于是在制度制定中有学生的高度参与，也建立了比较完善的反馈机制。很多人连维护自己权利的意识都没有，那也不用谈什么争取民主了。
 另外民主并不是表面的可以带手机不用穿校服=.=
议事会  我大概简化了一下深中的民主体系（我在的时代…）。感觉有点三权分立内味儿…查了下议事会的公众号。议事会通过组织会议，对学校的政策、学生的提议等进行讨论和修改。据我所知，议员由每个班选举产生，每个班两名，然后他们会定期or不定期开会讨论问题。有点民主集中制内味儿了…
 煮个栗子，放个会议记录，是关于修订《深圳中学学生行为指引》的一次会议。
学生会权益部  学生会的权益部是比较有意思的。感觉很多学校的学生会可能只是组织组织活动，我觉得他们没get到学生会的精髓…我在校的时候与学生会的接触比较少，于是搜了下学生会的公众号…
 点进去就能看到挺明显的维权通道，针不戳（有兴趣去翻翻他们的维权案例啊就近期维权申诉公示），随便翻了翻，有篮球场数量不够，灯光布置不合理；小卖部莫名涨价，冰箱不开；食堂菜量莫名减少之类之类的维权案例。收到维权申诉之后，学生会干事会去找相关部门、老师、食堂经理、物业之类的解决问题，并且会公示出申诉内容和处理结果。根据公示出的内容看来，他们确实帮助学生解决了问题。
 虽然看起来这些都是些小问题，吃点小亏就过去了，但小的权益你不维护，谁还指望你去维护大的权益。
 当纳粹来抓共产党人时，我保持沉默，因为我不是共产党人；当他们来抓犹太人时，我保持沉默，因为我不是犹太人；当他们来抓贸易工会主义者时，我保持沉默，因为我不是贸易工会主义者；当他们来抓天主教徒时，我保持沉默，因为我是新教徒；当他们来抓我时，已无人替我说话了。
—— 所以要不要先试着维护一下自己的权利
 我觉得最值得肯定的是学生的维权意识，你要知道去维护自己的权利，才会去找方法，建立这样的制度并维系下去。
18号农场  聊深中民主就免不了想到18号农场。有兴趣可以康康农场宣言。18号农场就是一个匿名的公众号，会发一些对校园时事的见解，接受投稿，所以纯粹为了喷的文章也不少…但还是有很多能引发思考or思想碰撞的文章的。（我i的可不就是深中人思想碰撞的火花）
 负责学生事务的老师是有关注这些文章的，所以学校政策和学生意识出现大的冲突时，一些偏激or客观有用的文字能让老师重新审视政策or制度。
 Btw，这样子学生高度参与的制度是需要老师的支持的，要让老师care你是要自己去争取的，要怎么做到让老师觉得你是在参与校园政治维护学生权益而不是在玩个校园政治过家家是需要努力和脑子的。
 有立法，维权，反馈这些方面，这样的校园民主制度我觉得是很完善的了，在教学之余能完善出这样的制度，我是非常佩服参与过这其中的深中人（不只是深中学子噢）的。
校园民主的误区  学生追求民主是好事，但也容易陷入一些误区，比如过于追求形式，错误地认为民主就是把老师和校方放在对立面。讲个校园民主的反例，就是我高一经历的“校猫听证会”。
 深中有很多猫，我们称它们为校猫。校猫平时是由校猫社和收发室的老师喂养的，猫粮都是师生捐赠的，会众筹给猫绝育、打疫苗，猫生病时也会众筹给它治病。平时猫就在校园里到处游荡，好不快活（校园特色…
 然后就是当年有只猫病了，好像很严重，然后一开始是众筹给猫治病，某学生组织有一直在跟进猫的治疗，时不时会通报一下猫的情况。后来又好像猫病的太严重了，校猫社无法承担医疗费用，且治疗风险很大。于是学生组织就搞了个投票要不要把猫给安乐死。这件事当时争议还挺大的，然后为了做出决定，于是开了个校猫听证会。
 然后在校猫听证会上，我在内的热心群众被宠物医院的兽医大哥喷的狗血淋头，说明明猫是很大概率可以治好的，我们却搞了个安乐死投票，不尊重生命，一般猫遇到这种情况都不会放弃治疗blablabla。然而从当时学生组织的公告和投票的描述来看，大家都以为猫是病得不轻，花几千元都很难治好的，很明显信息传达不到位！！！虽然当场很多学生都解释了信息传达不到位这件事，但兽医大哥还是喷的我很无语…
 这件事是想说，民主实践过程中请带脑子…
 另外，深中有很好的海报文化，学生组织/社团有大的决议、公告等会发布这样的文件，还会张贴在各种楼道、通道的墙上。就很有内味儿！
技大的民主模式雏形  一句话讲完版本：就是没有，希望各位有识之士快来建立。
 技大有学生会，有社联，但好像都是举办活动比较多，跟制度制定，维护学生权益没有很大关系…（虽然也有权益部）新学校，没有也很正常，不过什么社团发篇推文都要经过团委审核我真是闻所未闻，可能我孤陋寡闻了…
关于投诉反馈问题  我觉得现在最需要解决的问题是投诉无门（缺少高效的反馈渠道or反馈石沉大海）（貌似不只有学校存在这样的问题狗头）。有好多事情反馈给老师/物业/饭堂，打打太极就过去了…问题得不到解决。记得我刚来的时候经常说，这样这样要是在深中是分分钟要被挂到18号农场的…当时气的甚至想建立“技大农场”…但我怂…
 想想，如果有个学生组织的学生代表，代表大多数学生，去投诉/反馈一件事，是不是比我一个单一的个体去投诉/反馈要有力得多呢？
校长/书记面对面  技大有校长面对面和书记下午茶（党委书记），好像举办的还挺频繁的，但就是反馈的问题好像都是经过老师筛选的，参会人员也不知道是怎么产生的，真正有问题的问题会不会被掐死在半路呢？感觉就是徒有其表，只学到了个外壳罢了。上次在班里征集问题时征集了一堆，官微发记录推文的时候一个也没有问到…征集的问题貌似也没有再反馈回来。后来想了想，校长面对面这种是宣传意义比较大，因为官微推文在报道校长面对面这些活动时，都是在宣传学校的民生建设，活动制度之类的。
学校政策推行缺少学生参与  1.宿舍运营商只有联通，日常断网，甚至新生入学第一天网炸了，是谁让联通入驻的？跟进一下后期维护呗。（有学生在调查学生对联通的满意度了，兄弟加油！
 2.去年宿舍楼下单车乱放，某天通知都没有，物业就把半个学校的单车挪到另一块地方了，第二天早课到楼下一脸懵逼地在几百辆车里找车。（额今年新生报道前一天挪的那次终于知道要提前说了&hellip;）
 3.去年行业认知课程，学期末倒数第三周突然通知剩下三周每周二下午（工作日唯一大块无课的空余时间）去企业参观，废掉我整个下午大半个晚上。要期末考的好不…且不说参观交流质量有多差…
 4.学期最后一个周末校运会….（就&hellip;原谅我就缺席了呗..
 就，以上稍微征询一下学生意见都不会搞出这么荒唐的事吧…新学校刚起步，说是一天一个样都不过分，趁着各种制度都在完善中，希望各位有识之士快来参与建立好的制度，不要让不好的制度扎根，成为以后的“传统”，这样就难改了。
 迷惑行为大赏就写到这里。反正就，同为深圳市政（财）府（政）的亲儿砸，深圳中学的深中模式值得借鉴…
再多说几句  我觉得大学教育还应该培养学生的公民意识和社会责任，就，大学生这么多，有好多不会做人的…有机会写写讲讲教育问题…
 深中大概每月会有一次公民课堂，在周一集会上举行，会邀请到各种人讲各种事，主讲的人有学生有老师也有学校外的人。虽然公民课堂的效果有好有坏，但这样对学生的公民教育是种不错的尝试。（本想放图但公众号都找不到相关的内容&hellip;）
 我在的深中更像是象牙塔，有引导学生积极尝试的氛围，能包容学生的各种尝试，学生能“试出”真正的自己，成为一个社会中的完整的个体。我想这才是别的学校（国内外都）学不来的深中精神内核，才是打出“世界一流“名号最有力的依据。
Ending  深圳中学致力于培养具有丰富生命里的人。他们能自主发现和实现个人的潜能，成为他们最好的自己，而且他们无论身在何处，都能尊重自然，关爱他人，服务社会，造福世界，并且乐在其中。
——我最喜欢的一个版本，并且一直贴在我桌子上
 </content></entry><entry><title>Markdown语法手册</title><url>https://yinanhong.site/post/markdown-syntax/</url><categories><category>markdown</category></categories><tags><tag>theme</tag></tags><content type="html"> 本文提供了一个可以在Hugo内容文件中使用的基本Markdown语法示例，还展示了基本HTML元素在Hugo主题中是否使用CSS装饰。
Headings The following HTML &lt;h1>—&lt;h6> elements represent six levels of section headings. &lt;h1> is the highest section level while &lt;h6> is the lowest.
H1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.
Itatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.
Blockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.
Blockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.
Blockquote with attribution Don&rsquo;t communicate by sharing memory, share memory by communicating.
— Rob Pike1
Tables Tables aren&rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.
Name Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> Code block indented with four spaces &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> Code block with Hugo&rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.
H2O
Xn + Yn = Zn
Press CTRL+ALT+Delete to end the session.
Most salamanders are nocturnal, and hunt for insects, worms, and other small creatures.
  The above quote is excerpted from Rob Pike&rsquo;s talk during Gopherfest, November 18, 2015. &#8617;&#xfe0e;</content></entry><entry><title>富文本内容测试</title><url>https://yinanhong.site/post/rich-content/</url><categories/><tags><tag>theme</tag></tags><content type="html"> Hugo 雨果附带几个[内置的短码](https://gohugo.io/content-management/shortcodes/ use-hugos-built-in-shortcodes)内容丰富,以及隐私配置和一组简单的短码,使静态和no-JS版本的各种社会媒体嵌入。
YouTube Privacy Enhanced Shortcode Twitter Simple Shortcode .twitter-tweet { font: 14px/1.45 -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif; border-left: 4px solid #2b7bb9; padding-left: 1.5em; color: #555; } .twitter-tweet a { color: #2b7bb9; text-decoration: none; } blockquote.twitter-tweet a:hover, blockquote.twitter-tweet a:focus { text-decoration: underline; } Vimeo Simple Shortcode .__h_video { position: relative; padding-bottom: 56.23%; height: 0; overflow: hidden; width: 100%; background: #000; } .__h_video img { width: 100%; height: auto; color: #000; } .__h_video .play { height: 72px; width: 72px; left: 50%; top: 50%; margin-left: -36px; margin-top: -36px; position: absolute; cursor: pointer; }  </content></entry><entry><title>占位符文本显示</title><url>https://yinanhong.site/post/placeholder-text/</url><categories/><tags><tag>markdown</tag></tags><content type="html"> 你对我的心有偏见。我向您保证，我们的生活将不会受到影响，我们的生活将会受到影响。你说你现在住在医院里，因为你的眼睛是透明的，你的眼睛是光明的，你的眼睛是光明的!
Exierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.
Comas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt
The Van de Graaf Canon
Mane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.
Iubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.
Eurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.
 </content></entry><entry><title>数据公式设置显示</title><url>https://yinanhong.site/post/math-typesetting/</url><categories/><tags/><content type="html"> Hugo项目中的数学符号可以通过使用第三方JavaScript库来启用。
In this example we will be using KaTeX
Create a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial "math.html" . }} {{ end }} To enable KaTex globally set the parameter math to true in a project&rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions
Examples Block math: $$ \varphi = 1+\frac{1} {1+\frac{1} {1+\frac{1} {1+\cdots} } } $$
 </content></entry><entry><title>支持Emoji表情符号</title><url>https://yinanhong.site/post/emoji-support/</url><categories/><tags><tag>markdown</tag></tags><content type="html"> 在Hugo项目中可以通过多种方式启用Emoji。
The emojify function can be called directly in templates or Inline Shortcodes.
To enable emoji globally, set enableEmoji to true in your site&rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.
馃檲 🙈 馃檳 🙉 馃檴 🙊
The Emoji cheat sheet is a useful reference for emoji shorthand codes.
N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.
1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; }  </content></entry><entry><title>划水打卡日志</title><url>https://yinanhong.site/post/waterlog/</url><categories/><tags/><content type="html"> 周更不能保证质量，所以在这个页面记录一下一周的学习概况。有输入才有输出，也要高质量地输出。
2021.7.26 哈工大操作系统/linux 0.01内和分析学习概要
2021.7.17 欧洲杯真快乐。考完试玩了几天。
修复了本站的一点小bug
开始whosbug项目的前置学习。</content></entry></search>